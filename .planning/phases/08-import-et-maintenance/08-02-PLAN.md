---
phase: 08-import-et-maintenance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/enricher.py
  - src/services/integrity.py
  - src/adapters/cli/commands.py
  - src/container.py
  - src/main.py
  - tests/unit/services/test_enricher.py
  - tests/unit/services/test_integrity.py
autonomous: true

must_haves:
  truths:
    - "La commande enrich enrichit les fichiers non enrichis via API avec rate limiting"
    - "La commande repair-links detecte et repare les symlinks casses interactivement"
    - "La commande check verifie la coherence BDD/filesystem et affiche un rapport"
    - "Les symlinks orphelins sont deplaces vers trash/orphans"
    - "Le rapport check propose des suggestions de commandes correctives"
  artifacts:
    - path: "src/services/enricher.py"
      provides: "EnricherService avec rate limiting et retry"
      exports: ["EnricherService", "EnrichmentResult"]
    - path: "src/services/integrity.py"
      provides: "IntegrityChecker et RepairService"
      exports: ["IntegrityChecker", "IntegrityReport", "RepairService", "RepairAction"]
    - path: "tests/unit/services/test_enricher.py"
      provides: "Tests EnricherService"
      min_lines: 80
    - path: "tests/unit/services/test_integrity.py"
      provides: "Tests IntegrityChecker et RepairService"
      min_lines: 100
  key_links:
    - from: "src/adapters/cli/commands.py"
      to: "src/services/enricher.py"
      via: "container.enricher_service()"
      pattern: "enricher_service"
    - from: "src/adapters/cli/commands.py"
      to: "src/services/integrity.py"
      via: "container.integrity_checker() et container.repair_service()"
      pattern: "integrity_checker|repair_service"
    - from: "src/services/integrity.py"
      to: "src/adapters/file_system.py"
      via: "FileSystemAdapter.find_broken_links()"
      pattern: "find_broken_links"
---

<objective>
Implementer les services et commandes CLI de maintenance : enrich, repair-links, check.

Purpose: Fournir les outils pour enrichir les metadonnees via API, reparer les symlinks casses, et verifier l'integrite de la videotheque.

Output:
- EnricherService avec rate limiting et batch processing
- IntegrityChecker pour verification BDD/filesystem
- RepairService pour reparation interactive des symlinks
- Commandes CLI enrich, repair-links, check
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-import-et-maintenance/08-CONTEXT.md
@.planning/phases/08-import-et-maintenance/08-RESEARCH.md
@src/services/validation.py
@src/adapters/cli/commands.py
@src/adapters/file_system.py
@src/container.py
@src/adapters/api/tmdb_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer EnricherService avec rate limiting</name>
  <files>
    - src/services/enricher.py
    - tests/unit/services/test_enricher.py
  </files>
  <action>
Creer le service EnricherService dans src/services/enricher.py :

1. **Dataclasses de resultat** :
   - `EnrichmentResult` : enriched (int), failed (int), skipped (int)

2. **EnricherService** avec injection DI :
   - `__init__(pending_repo, video_file_repo, matcher, tmdb_client, tvdb_client)`
   - `RATE_LIMIT_DELAY = 0.25` : 4 req/s pour TMDB (40/10s)
   - `MAX_RETRIES = 3`

3. **Methodes principales** :
   - `list_pending_enrichment() -> list[PendingValidation]` : fichiers sans candidates ou avec candidates vides
   - `async enrich_batch(items, progress_callback, advance_callback) -> EnrichmentResult` :
     - Pour chaque item, appeler TMDB ou TVDB selon import_type
     - Utiliser matcher.score_results() pour scorer les candidats
     - Sauvegarder les candidates dans pending_repo
     - asyncio.sleep(RATE_LIMIT_DELAY) entre chaque requete
     - Try/except avec logging des erreurs, continuer avec les suivants
   - `async _enrich_single(pending) -> bool` : enrichit un seul fichier, retourne succes

4. **Detection du type** :
   - Utiliser video_file.entity_metadata.get("import_type") si disponible
   - Sinon, detecter via filename patterns (SxxExx -> series)

5. **Rate limiting** (selon 08-CONTEXT.md) :
   - Delay 0.25s entre chaque requete API
   - tenacity gere deja le retry avec backoff dans les clients
   - Apres 3 echecs, skip et logger l'echec

6. **Tests** dans tests/unit/services/test_enricher.py :
   - test_list_pending_enrichment_empty_candidates : retourne fichiers sans candidats
   - test_enrich_batch_respects_rate_limit : verifie asyncio.sleep est appele
   - test_enrich_single_movie : appelle tmdb_client.search()
   - test_enrich_single_series : appelle tvdb_client.search()
   - test_enrich_continues_on_error : erreur sur un fichier n'arrete pas le batch

Patterns a suivre : ValidationService pour la structure, request_with_retry dans les clients API.
  </action>
  <verify>
    pytest tests/unit/services/test_enricher.py -v
  </verify>
  <done>
    EnricherService avec 5+ tests passants. Rate limiting avec asyncio.sleep(0.25).
  </done>
</task>

<task type="auto">
  <name>Task 2: Creer IntegrityChecker et RepairService</name>
  <files>
    - src/services/integrity.py
    - tests/unit/services/test_integrity.py
  </files>
  <action>
Creer les services dans src/services/integrity.py :

### IntegrityChecker

1. **Dataclasses** :
   - `IntegrityIssue` : type (ghost_entry | orphan_file | broken_symlink), path, details
   - `IntegrityReport` : issues (list), to_json() method, has_issues property

2. **IntegrityChecker** avec injection DI :
   - `__init__(file_system, video_file_repo, storage_dir, video_dir)`
   - `check(verify_hash: bool = False) -> IntegrityReport` :
     - **Entrees fantomes** : dans BDD mais path n'existe pas sur disque
     - **Fichiers orphelins** : sur disque dans storage_dir mais pas dans BDD
     - **Symlinks casses** : file_system.find_broken_links(video_dir)
     - Si verify_hash=True, verifier que les hash correspondent
   - `_suggest_fixes(report) -> list[str]` : genere les commandes correctives

3. **Format rapport** (selon 08-CONTEXT.md) :
   - Texte structure par defaut avec sections par type d'inchoherence
   - Methode to_json() pour --json
   - Suggestions de commandes (ex: "cineorg repair-links" pour symlinks casses)

### RepairService

1. **Dataclasses** :
   - `RepairAction` : link (Path), action (repaired | orphaned | skipped), new_target (Optional[Path])

2. **RepairService** avec injection DI :
   - `__init__(file_system, video_file_repo, trash_dir)`
   - `find_broken_symlinks() -> list[Path]` : delegue a file_system.find_broken_links()
   - `find_possible_targets(link: Path) -> list[Path]` : cherche fichiers avec meme nom dans storage
   - `repair_symlink(link: Path, new_target: Path) -> bool` : supprime et recree le symlink
   - `move_to_orphans(link: Path) -> Path` : deplace vers trash/orphans avec timestamp si conflit
   - `save_log(actions: list[RepairAction]) -> Path` : ecrit repair-YYYY-MM-DD.log

3. **Tests** dans tests/unit/services/test_integrity.py :
   - test_check_finds_ghost_entries : entree BDD sans fichier -> ghost_entry
   - test_check_finds_orphan_files : fichier sans entree BDD -> orphan_file
   - test_check_finds_broken_symlinks : symlink casse -> broken_symlink
   - test_integrity_report_to_json : format JSON valide
   - test_find_possible_targets : trouve fichier avec meme nom
   - test_move_to_orphans_creates_directory : cree trash/orphans si necessaire
   - test_save_log_writes_file : fichier log cree avec actions

Patterns a suivre : FileSystemAdapter.find_broken_links() pour la detection.
  </action>
  <verify>
    pytest tests/unit/services/test_integrity.py -v
  </verify>
  <done>
    IntegrityChecker et RepairService avec 7+ tests passants. Rapport JSON fonctionnel.
  </done>
</task>

<task type="auto">
  <name>Task 3: Commandes CLI enrich, repair-links, check</name>
  <files>
    - src/adapters/cli/commands.py
    - src/container.py
    - src/main.py
  </files>
  <action>
### 1. Ajouter services au container.py

```python
from .services.enricher import EnricherService
from .services.integrity import IntegrityChecker, RepairService

enricher_service = providers.Factory(
    EnricherService,
    pending_repo=pending_validation_repository,
    video_file_repo=video_file_repository,
    matcher=matcher_service,
    tmdb_client=tmdb_client,
    tvdb_client=tvdb_client,
)

integrity_checker = providers.Factory(
    IntegrityChecker,
    file_system=file_system,
    video_file_repo=video_file_repository,
)

repair_service = providers.Factory(
    RepairService,
    file_system=file_system,
    video_file_repo=video_file_repository,
)
```

### 2. Commande enrich dans commands.py

```python
def enrich() -> None:
    """Enrichit les metadonnees des fichiers via API."""
    asyncio.run(_enrich_async())

async def _enrich_async() -> None:
    # Recuperer les fichiers a enrichir
    # Progress bar avec total=len(pending)
    # Appeler enricher.enrich_batch() avec callbacks
    # Afficher resume final
```

### 3. Commande repair_links dans commands.py (selon 08-CONTEXT.md)

```python
def repair_links() -> None:
    """Detecte et repare les symlinks casses interactivement."""
    asyncio.run(_repair_links_async())

async def _repair_links_async() -> None:
    # Trouver broken symlinks
    # Pour chaque lien :
    #   - Afficher Panel avec infos du lien
    #   - Prompt: chercher / supprimer / ignorer / quitter
    #   - Si chercher: afficher matches possibles, selection
    #   - Si supprimer: move_to_orphans()
    # Sauvegarder log avec save_log()
```

### 4. Commande check dans commands.py

```python
def check(
    json_output: Annotated[bool, typer.Option("--json", help="Format JSON")] = False,
    verify_hash: Annotated[bool, typer.Option("--verify-hash", help="Verifier hash")] = False,
) -> None:
    """Verifie l'integrite de la videotheque."""
    # Appeler integrity_checker.check()
    # Afficher rapport texte ou JSON selon option
    # Afficher suggestions de commandes correctives
```

### 5. Enregistrer dans main.py

```python
from src.adapters.cli.commands import enrich, repair_links, check

app.command()(enrich)
app.command(name="repair-links")(repair_links)
app.command()(check)
```
  </action>
  <verify>
    python -m src.main enrich --help
    python -m src.main repair-links --help
    python -m src.main check --help
    python -m src.main --help | grep -E "enrich|repair|check"
  </verify>
  <done>
    Trois commandes disponibles dans CLI. Help affiche les options correctement.
  </done>
</task>

</tasks>

<verification>
```bash
# Verifier services
pytest tests/unit/services/test_enricher.py -v
pytest tests/unit/services/test_integrity.py -v

# Verifier commandes CLI
python -m src.main enrich --help
python -m src.main repair-links --help
python -m src.main check --help
python -m src.main check --json

# Verifier integration
python -m src.main --help
```
</verification>

<success_criteria>
- [ ] EnricherService respecte rate limiting (0.25s entre requetes)
- [ ] IntegrityChecker detecte ghost entries, orphan files, broken symlinks
- [ ] RepairService propose targets et deplace vers trash/orphans
- [ ] Commande enrich avec progress bar
- [ ] Commande repair-links en mode interactif avec log
- [ ] Commande check avec --json et suggestions correctives
- [ ] Tests unitaires passent (>90% couverture services)
</success_criteria>

<output>
After completion, create `.planning/phases/08-import-et-maintenance/08-02-SUMMARY.md`
</output>
