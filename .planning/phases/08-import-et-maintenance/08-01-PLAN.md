---
phase: 08-import-et-maintenance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/importer.py
  - src/adapters/cli/commands.py
  - src/container.py
  - tests/unit/services/test_importer.py
autonomous: true

must_haves:
  truths:
    - "La commande import scanne recursivement le repertoire storage"
    - "Les fichiers avec hash deja connu sont ignores silencieusement"
    - "Les fichiers nouveaux sont ajoutes en pending_validation"
    - "Une barre de progression affiche le scan en cours"
    - "Un resume final affiche X importes, Y ignores, Z erreurs"
  artifacts:
    - path: "src/services/importer.py"
      provides: "ImporterService avec scan_library et detection doublons par hash"
      exports: ["ImporterService", "ImportResult", "ImportDecision"]
    - path: "tests/unit/services/test_importer.py"
      provides: "Tests unitaires ImporterService"
      min_lines: 100
  key_links:
    - from: "src/adapters/cli/commands.py"
      to: "src/services/importer.py"
      via: "container.importer_service()"
      pattern: "importer_service"
    - from: "src/services/importer.py"
      to: "src/infrastructure/persistence/repositories/video_file_repository.py"
      via: "video_file_repo.get_by_hash()"
      pattern: "get_by_hash"
---

<objective>
Implementer le service d'import de videotheque existante et la commande CLI `import`.

Purpose: Permettre d'importer une videotheque existante dans la base de donnees CineOrg sans retraiter les fichiers deja connus.

Output:
- ImporterService avec logique de detection doublons par hash
- Commande CLI `cineorg import [storage_dir]` avec progress bar et resume
- Integration complete dans le container DI
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-import-et-maintenance/08-CONTEXT.md
@.planning/phases/08-import-et-maintenance/08-RESEARCH.md
@src/services/validation.py
@src/adapters/cli/commands.py
@src/container.py
@src/infrastructure/persistence/repositories/video_file_repository.py
@src/infrastructure/persistence/hash_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer ImporterService avec logique import</name>
  <files>
    - src/services/importer.py
    - tests/unit/services/test_importer.py
  </files>
  <action>
Creer le service ImporterService dans src/services/importer.py :

1. **Dataclasses de resultat** :
   - `ImportDecision` (enum): IMPORT, SKIP_KNOWN, UPDATE_PATH, ERROR
   - `ImportResult` : filename, decision, error_message (optional)

2. **ImporterService** avec injection DI :
   - `__init__(file_system, filename_parser, media_info_extractor, video_file_repo, pending_repo, compute_hash_fn)`
   - `scan_library(storage_dir: Path) -> Generator[ImportResult, None, None]` : generateur qui yield chaque fichier traite
   - `_should_import(file_path: Path) -> ImportDecision` : verifie par hash d'abord, puis par path
   - `_import_file(file_path: Path) -> ImportResult` : cree VideoFile et PendingValidation

3. **Logique de detection doublons** (selon 08-CONTEXT.md) :
   - Calculer le hash du fichier avec compute_hash_fn
   - Si hash existe deja dans video_file_repo -> SKIP_KNOWN (ignorer silencieusement)
   - Si path existe mais hash different -> UPDATE_PATH (fichier modifie)
   - Sinon -> IMPORT (nouveau fichier)

4. **Detection du type** (Films/ ou Series/) :
   - Parcourir les parents du fichier pour detecter "Films" ou "Series" dans le chemin
   - Stocker dans video_file.entity_metadata comme {"import_type": "movie" | "series"}

5. **Tests TDD** dans tests/unit/services/test_importer.py :
   - test_skip_known_hash : fichier avec hash existant -> SKIP_KNOWN
   - test_import_new_file : nouveau fichier -> IMPORT, VideoFile et PendingValidation crees
   - test_detect_movie_type : fichier dans Films/ -> entity_metadata["import_type"] = "movie"
   - test_detect_series_type : fichier dans Series/ -> entity_metadata["import_type"] = "series"
   - test_scan_library_yields_results : generateur retourne les resultats un par un

Patterns a suivre :
- Utiliser le pattern generateur comme ScannerService.scan_downloads()
- Injecter compute_file_hash via constructeur pour testabilite
- Mock les repositories dans les tests
  </action>
  <verify>
    pytest tests/unit/services/test_importer.py -v
  </verify>
  <done>
    ImporterService avec 5+ tests passants. Detection doublons par hash fonctionnelle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Commande CLI import avec progress bar</name>
  <files>
    - src/adapters/cli/commands.py
    - src/container.py
  </files>
  <action>
1. **Ajouter ImporterService au container.py** :
   ```python
   from .services.importer import ImporterService
   from .infrastructure.persistence.hash_service import compute_file_hash

   importer_service = providers.Factory(
       ImporterService,
       file_system=file_system,
       filename_parser=filename_parser,
       media_info_extractor=media_info_extractor,
       video_file_repo=video_file_repository,
       pending_repo=pending_validation_repository,
       compute_hash_fn=compute_file_hash,
   )
   ```

2. **Ajouter fonction import_library dans commands.py** :
   ```python
   def import_library(
       storage_dir: Annotated[
           Optional[Path],
           typer.Argument(help="Repertoire de la videotheque a importer"),
       ] = None,
       dry_run: Annotated[
           bool,
           typer.Option("--dry-run", help="Simule sans modifier la BDD"),
       ] = False,
   ) -> None:
       """Importe une videotheque existante dans la base de donnees."""
       asyncio.run(_import_library_async(storage_dir, dry_run))
   ```

3. **Implementation _import_library_async** :
   - Utiliser Path(config.storage_dir) si storage_dir non fourni
   - Progress bar Rich avec SpinnerColumn + TextColumn + BarColumn + TaskProgressColumn
   - Compteurs : imported=0, skipped=0, errors=0
   - Pour chaque ImportResult du generateur :
     - Update progress description avec filename
     - Incrementer le compteur selon decision
   - Afficher resume final : "[green]{imported}[/green] importe(s), [yellow]{skipped}[/yellow] ignore(s), [red]{errors}[/red] erreur(s)"

4. **Gerer le mode dry_run** :
   - Si dry_run=True, ne pas appeler pending_repo.save() dans ImporterService
   - Afficher "[yellow]Mode dry-run - aucune modification[/yellow]" en debut

Pattern a suivre : _process_async dans commands.py pour la structure Progress.
  </action>
  <verify>
    python -m src.main import --help
    python -m src.main import --dry-run
  </verify>
  <done>
    Commande import disponible avec --help. Mode dry-run fonctionne sans erreur.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enregistrer commande import dans main.py et tests CLI</name>
  <files>
    - src/main.py
    - tests/unit/adapters/cli/test_commands.py
  </files>
  <action>
1. **Ajouter import_library a main.py** :
   - Importer `import_library` depuis src.adapters.cli.commands
   - Enregistrer avec `app.command(name="import")(import_library)`
   - Note: "import" est un mot reserve Python, donc utiliser name= explicitement

2. **Ajouter tests dans test_commands.py** :
   - test_import_command_help : `result = runner.invoke(app, ["import", "--help"])` -> code 0
   - test_import_command_dry_run : mock importer_service, verifier que scan_library est appele
   - test_import_displays_summary : verifier que le resume avec compteurs s'affiche

Patterns a suivre : tests existants dans test_commands.py avec CliRunner et mocking.
  </action>
  <verify>
    python -m src.main import --help
    python -m src.main --help | grep import
    pytest tests/unit/adapters/cli/test_commands.py -v -k import
  </verify>
  <done>
    Commande import visible dans --help. Tests CLI passent.
  </done>
</task>

</tasks>

<verification>
```bash
# Verifier que ImporterService est fonctionnel
pytest tests/unit/services/test_importer.py -v

# Verifier que la commande CLI est disponible
python -m src.main import --help

# Verifier l'integration complete
python -m src.main import --dry-run

# Tests CLI
pytest tests/unit/adapters/cli/test_commands.py -v -k import
```
</verification>

<success_criteria>
- [ ] ImporterService detecte les doublons par hash
- [ ] Generateur yield les resultats un par un
- [ ] Commande `cineorg import` disponible avec --dry-run
- [ ] Progress bar affiche le scan en cours
- [ ] Resume final affiche X importes, Y ignores, Z erreurs
- [ ] Tests unitaires passent (>90% couverture service)
</success_criteria>

<output>
After completion, create `.planning/phases/08-import-et-maintenance/08-01-SUMMARY.md`
</output>
