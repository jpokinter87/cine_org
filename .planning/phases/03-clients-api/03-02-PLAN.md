---
phase: 03-clients-api
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/adapters/api/tmdb_client.py
  - src/utils/constants.py
  - tests/unit/adapters/api/test_tmdb_client.py
  - tests/fixtures/tmdb_responses.py
autonomous: true
user_setup:
  - service: tmdb
    why: "API de metadonnees films"
    env_vars:
      - name: CINEORG_TMDB_API_KEY
        source: "TMDB -> Settings -> API -> API Read Access Token (v4 auth)"

must_haves:
  truths:
    - "Le client TMDB recherche des films par titre"
    - "Le client TMDB recupere les metadonnees completes d'un film"
    - "Les genres sont traduits en francais"
    - "Les resultats sont caches (recherches 24h, details 7j)"
    - "Les erreurs 429 sont gerees avec retry automatique"
  artifacts:
    - path: "src/adapters/api/tmdb_client.py"
      provides: "TMDB API client implementing IMediaAPIClient"
      exports: ["TMDBClient"]
      contains: "class TMDBClient(IMediaAPIClient)"
    - path: "src/utils/constants.py"
      provides: "TMDB genre ID to French name mapping"
      contains: "TMDB_GENRE_MAPPING"
    - path: "tests/fixtures/tmdb_responses.py"
      provides: "Mock API responses for testing"
      exports: ["TMDB_SEARCH_RESPONSE", "TMDB_MOVIE_DETAILS_RESPONSE"]
  key_links:
    - from: "src/adapters/api/tmdb_client.py"
      to: "src/core/ports/api_clients.py"
      via: "implements interface"
      pattern: "class TMDBClient\\(IMediaAPIClient\\)"
    - from: "src/adapters/api/tmdb_client.py"
      to: "src/adapters/api/cache.py"
      via: "constructor injection"
      pattern: "def __init__.*cache.*APICache"
    - from: "src/adapters/api/tmdb_client.py"
      to: "src/adapters/api/retry.py"
      via: "import and use"
      pattern: "request_with_retry"
---

<objective>
Implementer le client TMDB pour la recherche et recuperation des metadonnees films, avec caching et gestion du rate limiting.

Purpose: TMDB est la source principale de metadonnees pour les films. Le client doit implementer l'interface IMediaAPIClient definie en Phase 1 et utiliser l'infrastructure cache/retry de 03-01.

Output: TMDBClient fonctionnel avec tests complets utilisant respx pour mocker les appels API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-clients-api/03-RESEARCH.md
@.planning/phases/03-clients-api/03-CONTEXT.md
@src/core/ports/api_clients.py
@src/adapters/api/cache.py
@src/adapters/api/retry.py
</context>

<feature>
  <name>TMDBClient - TMDB API Client</name>
  <files>
    - src/adapters/api/tmdb_client.py
    - tests/unit/adapters/api/test_tmdb_client.py
    - tests/fixtures/tmdb_responses.py
    - src/utils/constants.py
  </files>
  <behavior>
    TMDBClient implements IMediaAPIClient for movie metadata retrieval.

    search(query, year=None) -> list[SearchResult]:
      - "Avatar" -> [SearchResult(id="19995", title="Avatar", year=2009, source="tmdb"), ...]
      - "Avatar", year=2009 -> filtered results for 2009
      - Cache key: "tmdb:search:{query}:{year}"
      - Returns empty list if no results

    get_details(movie_id) -> MediaDetails | None:
      - "19995" -> MediaDetails(id="19995", title="Avatar", year=2009, genres=("Science-Fiction", "Action", "Aventure"), duration_seconds=9720, ...)
      - Cache key: "tmdb:details:{movie_id}"
      - Returns None if movie not found (404)

    source property:
      - Returns "tmdb"

    Caching behavior:
      - Search results cached for 24 hours
      - Details cached for 7 days
      - Cache checked BEFORE API call (cache-first pattern)
      - Only successful responses cached

    Rate limiting:
      - 429 responses trigger retry with exponential backoff
      - Max 5 retries before failure

    Genre mapping:
      - TMDB returns genre IDs in search, genre names in details
      - French names used when available (language=fr-FR)
      - Fallback mapping in constants.py for edge cases
  </behavior>
  <implementation>
    TDD approach - write tests first, then implement.

    RED phase:
    1. Create tests/fixtures/tmdb_responses.py with mock API responses
    2. Write test_search_returns_search_results
    3. Write test_search_with_year_filter
    4. Write test_search_caches_results
    5. Write test_search_returns_cached_on_second_call
    6. Write test_search_checks_cache_before_api_call (verify cache.get called BEFORE any HTTP request)
    7. Write test_get_details_returns_media_details
    8. Write test_get_details_returns_none_on_404
    9. Write test_get_details_caches_results
    10. Write test_details_checks_cache_before_api_call (verify cache.get called BEFORE any HTTP request)
    11. Write test_source_property_returns_tmdb
    12. Write test_retries_on_429
    Run tests - all should FAIL

    GREEN phase:
    1. Add TMDB_GENRE_MAPPING to src/utils/constants.py if not exists
    2. Implement TMDBClient class:
       - Constructor takes api_key and APICache
       - Lazy-initialize httpx.AsyncClient with base_url and Bearer auth
    3. Implement search() with cache-first pattern:
       a) Call cache.get(cache_key) FIRST
       b) If cached value exists, return it immediately (no HTTP request)
       c) Only if cache miss: make HTTP request using request_with_retry
       d) Call cache.set_search(cache_key, results) to store response
       e) Return results
    4. Implement get_details() with cache-first pattern:
       a) Call cache.get(cache_key) FIRST
       b) If cached value exists, return it immediately (no HTTP request)
       c) Only if cache miss: make HTTP request using request_with_retry
       d) Call cache.set_details(cache_key, details) to store response
       e) Return details (or None if 404)
    5. Implement source property
    6. Implement close() for cleanup
    Run tests - all should PASS

    REFACTOR phase:
    - Extract common request logic if duplicated
    - Ensure proper async context manager pattern
  </implementation>
</feature>

<verification>
1. Tests: `pytest tests/unit/adapters/api/test_tmdb_client.py -v` - tous passent
2. Import: `from src.adapters.api.tmdb_client import TMDBClient`
3. Interface: `isinstance(TMDBClient(...), IMediaAPIClient)` returns True
4. Coverage: `pytest tests/unit/adapters/api/test_tmdb_client.py --cov=src/adapters/api/tmdb_client --cov-report=term-missing` >= 90%
</verification>

<success_criteria>
- TMDBClient implemente IMediaAPIClient (search, get_details, source)
- La recherche retourne des SearchResult avec id, title, year, source="tmdb"
- get_details retourne MediaDetails avec genres en francais, duration_seconds
- Le cache est consulte AVANT tout appel API (tests explicites le verifient)
- Les 429 sont retries automatiquement
- Tous les tests passent avec respx mockant les appels HTTP
</success_criteria>

<output>
After completion, create `.planning/phases/03-clients-api/03-02-SUMMARY.md`
</output>
