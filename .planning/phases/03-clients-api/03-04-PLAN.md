---
phase: 03-clients-api
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/services/matcher.py
  - tests/unit/services/test_matcher.py
autonomous: true

# NOTE: MatcherService is intentionally Wave 1 with no dependencies.
# It only requires SearchResult type from Phase 1 ports (src/core/ports/api_clients.py).
# Integration with TMDBClient/TVDBClient (Wave 2) happens at orchestrator level (Phase 6/7).
# This allows parallel execution: Plan 04 builds scoring logic while Plans 02-03 build API clients.

must_haves:
  truths:
    - "Le scoring films utilise 50% titre + 25% annee + 25% duree"
    - "Le scoring series utilise 100% titre"
    - "La tolerance annee est de +/-1 an"
    - "La tolerance duree est de +/-10%"
    - "Le seuil de validation automatique est 85%"
    - "Le scoring est deterministe (meme entree = meme sortie)"
  artifacts:
    - path: "src/services/matcher.py"
      provides: "MatcherService for scoring API results"
      exports: ["MatcherService", "calculate_movie_score", "calculate_series_score"]
      contains: "token_sort_ratio"
    - path: "tests/unit/services/test_matcher.py"
      provides: "Comprehensive scoring tests"
      contains: "def test_"
  key_links:
    - from: "src/services/matcher.py"
      to: "rapidfuzz"
      via: "fuzz and utils import"
      pattern: "from rapidfuzz import fuzz"
    - from: "src/services/matcher.py"
      to: "src/core/ports/api_clients.py"
      via: "SearchResult import"
      pattern: "from src.core.ports.api_clients import SearchResult"
---

<objective>
Implementer le service de scoring pour classer les resultats API par pertinence, avec formules distinctes pour films (titre+annee+duree) et series (titre seul).

Purpose: Le scoring permet de selectionner automatiquement le meilleur candidat parmi les resultats API. Un score >= 85% avec un seul candidat dominant = validation automatique. Le scoring doit etre deterministe pour des resultats reproductibles.

Output: MatcherService avec fonctions de scoring utilisant rapidfuzz, plus tests exhaustifs couvrant les cas limites.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-clients-api/03-RESEARCH.md
@.planning/phases/03-clients-api/03-CONTEXT.md
@src/core/ports/api_clients.py
@src/core/value_objects/media_info.py
</context>

<feature>
  <name>MatcherService - Scoring Service</name>
  <files>
    - src/services/matcher.py
    - tests/unit/services/test_matcher.py
  </files>
  <behavior>
    MatcherService calculates match scores between parsed filename metadata and API search results.

    calculate_movie_score(query_title, query_year, query_duration, candidate_title, candidate_year, candidate_duration) -> float:
      Scoring formula: 50% title + 25% year + 25% duration

      Title scoring (50%):
        - Uses rapidfuzz.fuzz.token_sort_ratio for word-order independence
        - Normalized via utils.default_process (lowercase, strip whitespace)
        - Returns 0-100

      Year scoring (25%):
        - Exact match or +/-1 year: 100%
        - Each additional year difference: -25%
        - Missing year (None): 0%

      Duration scoring (25%):
        - Within +/-10%: 100%
        - Each additional 10% deviation: -50%
        - Missing duration (None): 0%

      Examples:
        - ("Avatar", 2009, 9720, "Avatar", 2009, 9720) -> 100.0
        - ("Avatar", 2009, 9720, "Avatar", 2010, 9720) -> 100.0 (year tolerance)
        - ("Avatar", 2009, 9720, "Avatar", 2011, 9720) -> 87.5 (year penalty)
        - ("Avatar", 2009, 9720, "Avatar", 2009, 10000) -> 100.0 (duration within 10%)
        - ("Avatar", None, None, "Avatar", 2009, 9720) -> 50.0 (title only)

    calculate_series_score(query_title, candidate_title) -> float:
      Scoring formula: 100% title similarity

      - Uses rapidfuzz.fuzz.token_sort_ratio
      - Normalized via utils.default_process

      Examples:
        - ("Breaking Bad", "Breaking Bad") -> 100.0
        - ("breaking bad", "Breaking Bad") -> 100.0 (case insensitive)
        - ("Breaking Bad S01E05", "Breaking Bad") -> high score (token sort handles extras)

    score_results(results: list[SearchResult], query_title, query_year=None, query_duration=None, is_series=False) -> list[SearchResult]:
      - Calculates score for each result
      - Returns results sorted by score (descending)
      - Modifies result.score field
      - is_series=True uses calculate_series_score, else calculate_movie_score

    MATCH_THRESHOLD = 85:
      - Class constant for auto-validation threshold
      - Results >= 85% are candidates for automatic validation
  </behavior>
  <implementation>
    TDD approach - write tests first, then implement.

    RED phase:
    1. Write test_title_similarity_exact_match (100%)
    2. Write test_title_similarity_case_insensitive
    3. Write test_title_similarity_word_order_independent ("Bad Breaking" vs "Breaking Bad")
    4. Write test_year_exact_match (100%)
    5. Write test_year_tolerance_one_year (still 100%)
    6. Write test_year_penalty_two_years (75%)
    7. Write test_year_missing_is_zero
    8. Write test_duration_within_10_percent (100%)
    9. Write test_duration_outside_tolerance_penalty
    10. Write test_duration_missing_is_zero
    11. Write test_movie_score_formula_weights (50/25/25)
    12. Write test_series_score_title_only
    13. Write test_score_results_sorts_descending
    14. Write test_score_results_modifies_score_field
    15. Write test_scoring_is_deterministic (same input = same output)
    Run tests - all should FAIL

    GREEN phase:
    1. Create src/services/matcher.py
    2. Implement calculate_movie_score() with rapidfuzz
    3. Implement calculate_series_score() with rapidfuzz
    4. Implement score_results() sorting logic
    5. Add MATCH_THRESHOLD = 85 constant
    Run tests - all should PASS

    REFACTOR phase:
    - Extract title normalization to helper function
    - Ensure no floating point precision issues (round to 2 decimals)
  </implementation>

  <usage_example>
    Integration with API clients (happens at orchestrator level in Phase 6/7):

    ```python
    # In orchestrator or processing service (NOT in this plan):
    from src.adapters.api.tmdb_client import TMDBClient
    from src.services.matcher import MatcherService

    # 1. API client searches for candidates
    search_results = await tmdb_client.search("Avatar", year=2009)
    # Returns: [SearchResult(id="19995", title="Avatar", year=2009, source="tmdb"), ...]

    # 2. MatcherService scores and sorts results
    matcher = MatcherService()
    scored_results = matcher.score_results(
        results=search_results,
        query_title="Avatar",
        query_year=2009,
        query_duration=9720,
        is_series=False
    )
    # Returns: [SearchResult(id="19995", title="Avatar", year=2009, score=100.0), ...]

    # 3. Check for auto-validation
    if scored_results and scored_results[0].score >= matcher.MATCH_THRESHOLD:
        best_match = scored_results[0]
        # Proceed with automatic validation
    ```

    Note: This integration is implemented in Phase 6 (Processing Pipeline) or Phase 7 (CLI).
    Plan 04 only implements the scoring logic. The wiring happens later.
  </usage_example>
</feature>

<verification>
1. Tests: `pytest tests/unit/services/test_matcher.py -v` - tous passent
2. Import: `from src.services.matcher import MatcherService, calculate_movie_score, calculate_series_score`
3. Coverage: `pytest tests/unit/services/test_matcher.py --cov=src/services/matcher --cov-report=term-missing` >= 95%
4. Determinism: Run same test 10 times, same results
</verification>

<success_criteria>
- calculate_movie_score applique la formule 50% titre + 25% annee + 25% duree
- calculate_series_score utilise 100% titre
- La tolerance annee (+/-1) est respectee
- La tolerance duree (+/-10%) est respectee
- Le scoring est deterministe (pas de variation entre executions)
- score_results trie les resultats par score decroissant
- MATCH_THRESHOLD = 85 est defini comme constante
- Tous les tests passent
</success_criteria>

<output>
After completion, create `.planning/phases/03-clients-api/03-04-SUMMARY.md`
</output>
