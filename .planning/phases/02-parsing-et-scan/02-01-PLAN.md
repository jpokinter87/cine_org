---
phase: 02-parsing-et-scan
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/ports/parser.py
  - src/core/value_objects/parsed_info.py
  - src/core/value_objects/__init__.py
  - src/services/scanner.py
  - src/adapters/file_system.py
  - tests/unit/test_scanner.py
autonomous: true

must_haves:
  truths:
    - "ParsedFilename contient titre, annee, type media, saison, episode"
    - "MediaType enum distingue MOVIE, SERIES, UNKNOWN"
    - "ScannerService peut lister les fichiers video d'un repertoire"
    - "Les fichiers < 100MB sont filtres"
    - "Les patterns ignores (sample, trailer) sont exclus"
    - "Les symlinks ne sont pas suivis"
  artifacts:
    - path: "src/core/ports/parser.py"
      provides: "IFilenameParser et IMediaInfoExtractor interfaces"
      exports: ["IFilenameParser", "IMediaInfoExtractor", "ParsedFilename", "MediaType"]
    - path: "src/core/value_objects/parsed_info.py"
      provides: "ParsedFilename et MediaType value objects"
      exports: ["ParsedFilename", "MediaType"]
    - path: "src/services/scanner.py"
      provides: "ScannerService orchestrating scanning and parsing"
      exports: ["ScannerService", "ScanResult"]
    - path: "src/adapters/file_system.py"
      provides: "FileSystemAdapter implementing IFileSystem"
      exports: ["FileSystemAdapter"]
  key_links:
    - from: "src/services/scanner.py"
      to: "src/core/ports/parser.py"
      via: "constructor injection"
      pattern: "IFilenameParser|IMediaInfoExtractor"
    - from: "src/services/scanner.py"
      to: "src/core/ports/file_system.py"
      via: "constructor injection"
      pattern: "IFileSystem"
---

<objective>
Creer l'infrastructure de scanning: ports pour le parsing, value objects pour les donnees parsees, et service de scan orchestrant le tout.

Purpose: Etablir les fondations du scan en respectant l'architecture hexagonale - les ports definissent les contrats, le service orchestre, les adaptateurs viendront dans le plan suivant.

Output: Ports IFilenameParser et IMediaInfoExtractor, value objects ParsedFilename et MediaType, ScannerService fonctionnel avec tests unitaires.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-parsing-et-scan/02-RESEARCH.md

# Phase 1 context - existing interfaces and patterns
@src/core/ports/file_system.py
@src/core/value_objects/media_info.py
@src/core/entities/video.py
@src/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ports et value objects pour le parsing</name>
  <files>
    src/core/ports/parser.py
    src/core/value_objects/parsed_info.py
    src/core/value_objects/__init__.py
  </files>
  <action>
Creer les interfaces et value objects:

1. **src/core/value_objects/parsed_info.py** - Value objects immutables:
   - `MediaType(Enum)`: MOVIE, SERIES, UNKNOWN
   - `ParsedFilename(@dataclass(frozen=True))`:
     - title: str
     - year: Optional[int]
     - media_type: MediaType = MediaType.UNKNOWN
     - season: Optional[int] = None
     - episode: Optional[int] = None
     - episode_end: Optional[int] = None (pour double episodes)
     - episode_title: Optional[str] = None
     - video_codec: Optional[str] = None
     - audio_codec: Optional[str] = None
     - resolution: Optional[str] = None
     - source: Optional[str] = None (HDTV, BluRay, WEB-DL)
     - release_group: Optional[str] = None
     - language: Optional[str] = None

2. **src/core/ports/parser.py** - Interfaces abstraites:
   - `IFilenameParser(ABC)`:
     - `parse(filename: str, type_hint: Optional[MediaType] = None) -> ParsedFilename`
   - `IMediaInfoExtractor(ABC)`:
     - `extract(file_path: Path) -> Optional[MediaInfo]`

3. Mettre a jour **src/core/value_objects/__init__.py** pour exporter ParsedFilename et MediaType.

Suivre les patterns existants: @dataclass(frozen=True) pour immutabilite, ABC avec @abstractmethod pour les ports.
  </action>
  <verify>
python -c "from src.core.value_objects import ParsedFilename, MediaType; from src.core.ports.parser import IFilenameParser, IMediaInfoExtractor; print('OK')"
  </verify>
  <done>
ParsedFilename et MediaType sont des value objects immutables. IFilenameParser et IMediaInfoExtractor sont des interfaces abstraites importables.
  </done>
</task>

<task type="auto">
  <name>Task 2: FileSystemAdapter et ScannerService</name>
  <files>
    src/adapters/file_system.py
    src/services/scanner.py
  </files>
  <action>
Creer l'adaptateur filesystem et le service de scan:

1. **src/adapters/file_system.py** - Implementation de IFileSystem:
   - Implementer `exists()`, `get_size()`, `move()`, `copy()`, `delete()`, `calculate_hash()`
   - Pour `read_metadata()`: retourner None pour l'instant (sera wire au MediaInfoExtractor)
   - Ajouter une methode helper `list_video_files(directory: Path) -> Iterator[Path]`:
     - Utiliser `pathlib.rglob('*')` pour le scan recursif
     - Filtrer par VIDEO_EXTENSIONS (definir comme constante: .mkv, .mp4, .avi, .mov, .wmv, .flv, .webm, .m4v)
     - Exclure les symlinks via `path.is_symlink()`
     - Exclure les fichiers contenant IGNORED_PATTERNS (sample, trailer, preview, extras, bonus)
     - Exclure les fichiers < min_file_size_bytes

2. **src/services/scanner.py** - Service orchestrant le scan:
   ```python
   @dataclass
   class ScanResult:
       video_file: VideoFile
       parsed_info: ParsedFilename
       detected_type: MediaType
       source_directory: str  # "Films" ou "Series"
       corrected_location: bool  # True si type != hint du repertoire

   class ScannerService:
       def __init__(
           self,
           file_system: IFileSystem,
           filename_parser: IFilenameParser,
           media_info_extractor: IMediaInfoExtractor,
           settings: Settings,
       ):
           ...

       def scan_downloads(self) -> Iterator[ScanResult]:
           """Scanne downloads_dir/Films et downloads_dir/Series"""
           downloads = self._settings.downloads_dir
           for subdir, type_hint in [("Films", MediaType.MOVIE), ("Series", MediaType.SERIES)]:
               source_dir = downloads / subdir
               if source_dir.exists():
                   yield from self._scan_directory(source_dir, type_hint)

       def _scan_directory(self, directory: Path, type_hint: MediaType) -> Iterator[ScanResult]:
           # Pour chaque fichier video trouve:
           # 1. Creer VideoFile avec path, filename, size_bytes
           # 2. Parser le filename avec type_hint
           # 3. Extraire media_info via extractor
           # 4. Detecter si corrected_location (type detecte != type_hint)
           # 5. Yield ScanResult
   ```

Note: Pour le hash, utiliser SHA-256 sur les premiers 10MB du fichier (pas le fichier entier pour performance).
  </action>
  <verify>
python -c "from src.adapters.file_system import FileSystemAdapter; from src.services.scanner import ScannerService, ScanResult; print('OK')"
  </verify>
  <done>
FileSystemAdapter implemente IFileSystem avec filtrage des videos. ScannerService orchestre scan + parsing + extraction avec yield des ScanResult.
  </done>
</task>

<task type="auto">
  <name>Task 3: Tests unitaires du scanner</name>
  <files>
    tests/unit/test_scanner.py
    tests/conftest.py
  </files>
  <action>
Creer les tests unitaires avec mocks:

1. **tests/conftest.py** - Fixtures partagees:
   - `mock_file_system`: Mock de IFileSystem
   - `mock_filename_parser`: Mock de IFilenameParser
   - `mock_media_extractor`: Mock de IMediaInfoExtractor
   - `test_settings`: Settings avec paths temporaires

2. **tests/unit/test_scanner.py** - Tests du ScannerService:
   - `test_scan_filters_small_files`: Fichiers < 100MB exclus
   - `test_scan_filters_sample_files`: Fichiers avec "sample" dans le nom exclus
   - `test_scan_filters_symlinks`: Symlinks exclus
   - `test_scan_detects_video_extensions`: Seuls .mkv, .mp4 etc. inclus
   - `test_scan_provides_type_hint_from_directory`: Films/ -> MediaType.MOVIE, Series/ -> MediaType.SERIES
   - `test_scan_detects_corrected_location`: Serie dans Films/ detectee comme corrected
   - `test_scan_returns_scan_result_with_all_fields`: Tous les champs ScanResult peuples

Utiliser pytest avec fixtures et mocks. Ne pas creer de vrais fichiers.
  </action>
  <verify>
cd /home/jp/PythonProject/cine_org && python -m pytest tests/unit/test_scanner.py -v
  </verify>
  <done>
Tests passent: filtrage par taille, extension, patterns ignores, symlinks. Type hint du repertoire et detection de correction fonctionnent.
  </done>
</task>

</tasks>

<verification>
Verification globale du plan:

```bash
# Imports fonctionnent
python -c "
from src.core.value_objects import ParsedFilename, MediaType
from src.core.ports.parser import IFilenameParser, IMediaInfoExtractor
from src.adapters.file_system import FileSystemAdapter
from src.services.scanner import ScannerService, ScanResult
print('All imports OK')
"

# Tests passent
cd /home/jp/PythonProject/cine_org && python -m pytest tests/unit/test_scanner.py -v

# Structure hexagonale respectee (ports abstraits, service utilise interfaces)
grep -l "ABC" src/core/ports/parser.py
grep -l "IFilenameParser" src/services/scanner.py
```
</verification>

<success_criteria>
- [ ] ParsedFilename et MediaType sont des value objects immutables (@dataclass(frozen=True))
- [ ] IFilenameParser et IMediaInfoExtractor sont des ABC avec @abstractmethod
- [ ] FileSystemAdapter implemente IFileSystem avec filtrage videos
- [ ] ScannerService utilise l'injection de dependances (pas d'instanciation directe)
- [ ] Les tests unitaires passent avec mocks (pas de vrais fichiers)
- [ ] Le filtrage exclut: taille < 100MB, patterns ignores, symlinks, extensions non-video
</success_criteria>

<output>
After completion, create `.planning/phases/02-parsing-et-scan/02-01-SUMMARY.md`
</output>
