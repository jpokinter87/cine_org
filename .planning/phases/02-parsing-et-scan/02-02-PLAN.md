---
phase: 02-parsing-et-scan
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/adapters/parsing/__init__.py
  - src/adapters/parsing/guessit_parser.py
  - src/adapters/parsing/mediainfo_extractor.py
  - src/container.py
  - tests/unit/test_guessit_parser.py
  - tests/unit/test_mediainfo_extractor.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Guessit extrait titre, annee, saison, episode des noms de fichiers"
    - "Guessit respecte le type_hint du repertoire source"
    - "MediaInfo extrait resolution, codecs, langues, duree"
    - "La duree est en secondes (pas millisecondes)"
    - "Les double episodes (S01E01E02) sont detectes"
    - "Le container DI fournit les parsers injectes"
  artifacts:
    - path: "src/adapters/parsing/guessit_parser.py"
      provides: "GuessitFilenameParser implementing IFilenameParser"
      exports: ["GuessitFilenameParser"]
    - path: "src/adapters/parsing/mediainfo_extractor.py"
      provides: "MediaInfoExtractor implementing IMediaInfoExtractor"
      exports: ["MediaInfoExtractor"]
    - path: "tests/unit/test_guessit_parser.py"
      provides: "Unit tests for filename parsing"
      min_lines: 50
    - path: "tests/unit/test_mediainfo_extractor.py"
      provides: "Unit tests for technical metadata extraction"
      min_lines: 30
  key_links:
    - from: "src/adapters/parsing/guessit_parser.py"
      to: "src/core/ports/parser.py"
      via: "implements interface"
      pattern: "class GuessitFilenameParser\\(IFilenameParser\\)"
    - from: "src/adapters/parsing/mediainfo_extractor.py"
      to: "src/core/ports/parser.py"
      via: "implements interface"
      pattern: "class MediaInfoExtractor\\(IMediaInfoExtractor\\)"
    - from: "src/container.py"
      to: "src/adapters/parsing"
      via: "DI providers"
      pattern: "GuessitFilenameParser|MediaInfoExtractor"
---

<objective>
Implementer les adaptateurs guessit et pymediainfo qui respectent les ports definis, avec tests TDD pour guessit.

Purpose: Fournir les implementations concretes du parsing de fichiers. Guessit pour les noms de fichiers (TDD car input/output clair), pymediainfo pour les metadonnees techniques.

Output: GuessitFilenameParser et MediaInfoExtractor fonctionnels, integres dans le container DI, avec tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-parsing-et-scan/02-RESEARCH.md

# From Plan 01 - interfaces to implement
@src/core/ports/parser.py
@src/core/value_objects/parsed_info.py
@src/core/value_objects/media_info.py

# DI container to extend
@src/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Tests GuessitFilenameParser puis implementation</name>
  <files>
    tests/unit/test_guessit_parser.py
    src/adapters/parsing/__init__.py
    src/adapters/parsing/guessit_parser.py
    requirements.txt
  </files>
  <action>
**RED - Ecrire les tests d'abord:**

1. Creer **tests/unit/test_guessit_parser.py** avec les cas de test:

```python
# Films
("Inception.2010.1080p.BluRay.x264-SPARKS.mkv", None) -> title="Inception", year=2010, media_type=MOVIE
("The.Matrix.1999.FRENCH.720p.BluRay.mkv", MediaType.MOVIE) -> title="The Matrix", year=1999, language="FR"
("Star.Wars.Episode.IV.A.New.Hope.1977.mkv", MediaType.MOVIE) -> title contient "Star Wars", year=1977, media_type=MOVIE (pas episode!)

# Series
("Breaking.Bad.S01E01.720p.HDTV.x264-CTU.mkv", None) -> title="Breaking Bad", season=1, episode=1, media_type=SERIES
("Game.of.Thrones.S03E09E10.1080p.mkv", MediaType.SERIES) -> season=3, episode=9, episode_end=10
("The.Office.US.S02E03.The.Dundies.mkv", None) -> episode_title="The Dundies"

# Type hint override
("Movie.Name.S01E01.mkv", MediaType.MOVIE) -> Respecte le hint, detecte comme MOVIE meme si ressemble a serie

# Technical info from filename
("Movie.2020.x265.AAC.1080p.mkv", None) -> video_codec="x265", audio_codec="AAC", resolution="1080p"
```

2. Ajouter `guessit>=3.8.0` dans **requirements.txt**.

3. Creer **src/adapters/parsing/__init__.py** (vide pour init).

**GREEN - Implementer pour faire passer les tests:**

4. Creer **src/adapters/parsing/guessit_parser.py**:
   - Classe `GuessitFilenameParser(IFilenameParser)`
   - Methode `parse(filename, type_hint)`:
     - Construire options dict: `{'type': 'movie'}` ou `{'type': 'episode'}` selon type_hint
     - Appeler `guessit(filename, options)`
     - Mapper le resultat vers ParsedFilename
   - Methode privee `_map_type(guessit_type)`: movie->MOVIE, episode->SERIES, autre->UNKNOWN
   - Methode privee `_get_episode_end(result)`: Si episode est une liste, retourner le dernier element
   - Methode privee `_extract_language(result)`: Extraire lang.alpha2.upper() du Babelfish Language

**Important:** Le type_hint doit etre respecte - ne pas laisser guessit overrider si le hint est fourni.
  </action>
  <verify>
cd /home/jp/PythonProject/cine_org && pip install guessit>=3.8.0 && python -m pytest tests/unit/test_guessit_parser.py -v
  </verify>
  <done>
GuessitFilenameParser parse correctement films et series. Les tests couvrent: type detection, type hint override, double episodes, technical info from filename.
  </done>
</task>

<task type="auto">
  <name>Task 2: MediaInfoExtractor avec tests</name>
  <files>
    src/adapters/parsing/mediainfo_extractor.py
    tests/unit/test_mediainfo_extractor.py
    requirements.txt
  </files>
  <action>
1. Ajouter `pymediainfo>=7.0.1` dans **requirements.txt**.

2. Creer **src/adapters/parsing/mediainfo_extractor.py**:
   - Classe `MediaInfoExtractor(IMediaInfoExtractor)`
   - Methode `extract(file_path: Path) -> Optional[MediaInfo]`:
     - Verifier que le fichier existe
     - Appeler `PyMediaInfo.parse(str(file_path), full=True)`
     - Extraire resolution depuis video_tracks[0].width/height
     - Extraire video_codec depuis video_tracks[0].format
     - Extraire audio_codecs depuis tous les audio_tracks
     - Extraire audio_languages depuis audio_tracks[].language
     - **CRITICAL:** Extraire duration en DIVISANT par 1000 (pymediainfo retourne des millisecondes!)
     - Retourner None si exception ou fichier invalide
   - Methodes privees de normalisation:
     - `_normalize_video_codec(codec)`: avc/h264/x264->x264, hevc/h265/x265->x265
     - `_normalize_audio_codec(codec)`: ac-3->AC3, dts-hd ma->DTS-HD, etc.
     - `_format_channels(count)`: 2->2.0, 6->5.1, 8->7.1
     - `_get_language_name(code)`: fr->Francais, en->Anglais

3. Creer **tests/unit/test_mediainfo_extractor.py**:
   - Ces tests necesitent des mocks car on ne peut pas creer de vrais fichiers video
   - Mocker `PyMediaInfo.parse()` pour retourner des objets avec les attributs attendus
   - Tester:
     - `test_extract_returns_none_for_missing_file`
     - `test_extract_duration_converted_from_ms_to_seconds` (7200000 -> 7200)
     - `test_extract_resolution_from_video_track`
     - `test_extract_audio_languages_deduped` (pas de doublons)
     - `test_normalize_video_codec_variants` (H.264, AVC, x264 -> x264)
  </action>
  <verify>
cd /home/jp/PythonProject/cine_org && pip install pymediainfo>=7.0.1 && python -m pytest tests/unit/test_mediainfo_extractor.py -v
  </verify>
  <done>
MediaInfoExtractor extrait resolution, codecs, langues, duree (en secondes). Tests avec mocks valident la conversion duree et normalisation codecs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration DI et test end-to-end</name>
  <files>
    src/container.py
    src/adapters/__init__.py
    tests/integration/test_scanner_integration.py
  </files>
  <action>
1. Mettre a jour **src/adapters/__init__.py** pour exporter les nouveaux adaptateurs.

2. Mettre a jour **src/container.py** pour ajouter les providers:
```python
from dependency_injector import containers, providers
from src.adapters.file_system import FileSystemAdapter
from src.adapters.parsing.guessit_parser import GuessitFilenameParser
from src.adapters.parsing.mediainfo_extractor import MediaInfoExtractor
from src.services.scanner import ScannerService

class Container(containers.DeclarativeContainer):
    config = providers.Configuration()
    settings = providers.Singleton(Settings)

    # Adapters
    file_system = providers.Singleton(FileSystemAdapter)
    filename_parser = providers.Singleton(GuessitFilenameParser)
    media_info_extractor = providers.Singleton(MediaInfoExtractor)

    # Services
    scanner_service = providers.Factory(
        ScannerService,
        file_system=file_system,
        filename_parser=filename_parser,
        media_info_extractor=media_info_extractor,
        settings=settings,
    )
```

3. Creer **tests/integration/test_scanner_integration.py**:
   - Test avec vrais adaptateurs (pas de mocks)
   - Creer un repertoire temporaire avec structure Films/Series
   - Creer de vrais fichiers vides (ou tres petits) pour tester le filtrage par taille
   - Verifier que le scanner orchestre correctement le flow complet
   - Note: Ce test ne peut pas vraiment tester pymediainfo sur des fichiers vides, mais peut tester le flow

4. Ajouter commande CLI `scan` dans **src/main.py**:
```python
@app.command()
def scan():
    """Scanne les repertoires de telechargements."""
    container = Container()
    container.init_resources()
    scanner = container.scanner_service()

    count = 0
    for result in scanner.scan_downloads():
        typer.echo(f"Found: {result.video_file.filename}")
        typer.echo(f"  Type: {result.detected_type.value}")
        typer.echo(f"  Title: {result.parsed_info.title}")
        if result.corrected_location:
            typer.echo(f"  WARNING: File in wrong directory!")
        count += 1

    typer.echo(f"\nTotal: {count} files found")
```
  </action>
  <verify>
cd /home/jp/PythonProject/cine_org && python -m pytest tests/integration/test_scanner_integration.py -v && python -m src.main scan --help
  </verify>
  <done>
Container DI fournit ScannerService avec tous les adaptateurs. La commande CLI `scan` est disponible et fonctionne.
  </done>
</task>

</tasks>

<verification>
Verification globale du plan:

```bash
# Tous les tests passent
cd /home/jp/PythonProject/cine_org && python -m pytest tests/ -v

# Imports fonctionnent depuis le container
python -c "
from src.container import Container
c = Container()
scanner = c.scanner_service()
print(f'Scanner service: {scanner}')
print('Container wiring OK')
"

# CLI scan disponible
python -m src.main scan --help
```
</verification>

<success_criteria>
- [ ] GuessitFilenameParser parse films et series correctement (tests TDD passent)
- [ ] Type hint du repertoire est respecte (Films/ force movie meme si filename ressemble a serie)
- [ ] MediaInfoExtractor extrait toutes les metadonnees techniques
- [ ] La duree est en SECONDES (pas millisecondes)
- [ ] Les double episodes sont detectes (episode + episode_end)
- [ ] Container DI fournit ScannerService avec tous les adaptateurs injectes
- [ ] Commande CLI `scan` existe et peut lister les fichiers
</success_criteria>

<output>
After completion, create `.planning/phases/02-parsing-et-scan/02-02-SUMMARY.md`
</output>
