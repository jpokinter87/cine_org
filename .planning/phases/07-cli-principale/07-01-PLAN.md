---
phase: 07-cli-principale
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.py
  - src/adapters/cli/commands.py
  - src/infrastructure/persistence/repositories/pending_validation_repository.py
  - src/services/validation.py
  - tests/unit/adapters/cli/test_commands.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "La commande process execute le workflow complet: scan -> matching -> auto-validation -> interactive -> transfert"
    - "La commande pending affiche les fichiers en attente avec leurs candidats"
    - "La commande validate file permet de valider un fichier specifique par ID"
    - "Les options --verbose/-v et --quiet/-q ajustent le niveau de detail"
    - "Le mode --dry-run simule sans modifier les fichiers"
  artifacts:
    - path: "src/main.py"
      provides: "CLI principale avec commandes process, pending et callback verbose/quiet"
      contains: "@app.command"
    - path: "src/adapters/cli/commands.py"
      provides: "Implementation des commandes avec workflow orchestration"
      contains: "def process"
    - path: "src/infrastructure/persistence/repositories/pending_validation_repository.py"
      provides: "Methode get_by_id pour recuperer un pending par son ID"
      contains: "def get_by_id"
    - path: "src/services/validation.py"
      provides: "Methode get_pending_by_id exposee par le service"
      contains: "def get_pending_by_id"
    - path: "tests/unit/adapters/cli/test_commands.py"
      provides: "Tests des nouvelles commandes incluant cas d'erreur"
      contains: "test_process"
  key_links:
    - from: "src/main.py"
      to: "src/adapters/cli/commands.py"
      via: "app.add_typer(validate_app) pour les sous-commandes validate"
      pattern: "validate_app"
    - from: "src/adapters/cli/commands.py"
      to: "src/container.py"
      via: "Container().scanner_service(), validation_service()"
      pattern: "container\\."
    - from: "src/services/validation.py"
      to: "src/infrastructure/persistence/repositories/pending_validation_repository.py"
      via: "self._pending_repo.get_by_id()"
      pattern: "_pending_repo\\.get_by_id"
---

<objective>
Ajouter les commandes CLI principales (process, pending, validate file) au point d'entree CineOrg

Purpose: Fournir le workflow complet de traitement video utilisable en ligne de commande
Output: Commandes CLI fonctionnelles avec progression Rich, dry-run et verbose/quiet
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cli-principale/07-CONTEXT.md
@.planning/phases/07-cli-principale/07-RESEARCH.md
@.planning/phases/06-validation/06-02-SUMMARY.md

# Code existant a etendre
@src/main.py
@src/adapters/cli/commands.py
@src/adapters/cli/validation.py
@src/container.py
@src/services/validation.py
@src/services/scanner.py
@src/infrastructure/persistence/repositories/pending_validation_repository.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Etendre main.py avec callback global et monter validate_app</name>
  <files>src/main.py</files>
  <action>
Modifier main.py pour:

1. Ajouter un callback Typer pour options globales verbose/quiet:
```python
from typing import Annotated
from enum import Enum

# Etat global pour les options de verbosite
state = {"verbose": 0, "quiet": False}

@app.callback()
def main_callback(
    verbose: Annotated[int, typer.Option("--verbose", "-v", count=True,
        help="Augmenter la verbosite (-v, -vv, -vvv)")] = 0,
    quiet: Annotated[bool, typer.Option("--quiet", "-q",
        help="Mode silencieux (erreurs uniquement)")] = False,
) -> None:
    """CineOrg - Gestion de videotheque personnelle."""
    if quiet:
        state["quiet"] = True
    else:
        state["verbose"] = verbose
```

2. Monter validate_app comme sous-commande:
```python
from src.adapters.cli.commands import validate_app

# Dans la configuration de app:
app.add_typer(validate_app, name="validate")
```

Note: L'ordre dans main.py est important:
- D'abord le callback
- Puis les commandes simples (info, version, scan)
- La fonction main() reste le point d'entree
  </action>
  <verify>
```bash
python -m src.main --help
# Doit montrer les options --verbose/-v et --quiet/-q
# Doit lister validate comme sous-commande

python -m src.main validate --help
# Doit montrer auto, manual, batch comme sous-commandes
```
  </verify>
  <done>
- Le callback global capture verbose/quiet avant toute commande
- La sous-commande validate est accessible avec ses 3 commandes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implementer les commandes process et pending</name>
  <files>src/adapters/cli/commands.py, src/main.py</files>
  <action>
Ajouter dans commands.py les nouvelles commandes:

1. Enum MediaFilter:
```python
class MediaFilter(str, Enum):
    """Filtre par type de media."""
    ALL = "all"
    MOVIES = "movies"
    SERIES = "series"
```

2. Commande process avec workflow complet:
```python
@app.command()  # Sera importe dans main.py
def process(
    filter_type: Annotated[MediaFilter, typer.Option(
        "--filter", "-f", help="Type de medias a traiter")] = MediaFilter.ALL,
    dry_run: Annotated[bool, typer.Option(
        "--dry-run", help="Simule sans modifier les fichiers")] = False,
) -> None:
    """Execute le workflow complet: scan -> matching -> validation -> transfert."""
    asyncio.run(_process_async(filter_type, dry_run))

async def _process_async(filter_type: MediaFilter, dry_run: bool) -> None:
    # 1. Init container et services
    container = Container()
    await container.database.init()
    scanner = container.scanner_service()
    matcher = container.matcher_service()
    validation_svc = container.validation_service()
    config = container.config()

    # 2. Scan avec Progress
    with Progress(...) as progress:
        scan_task = progress.add_task("[cyan]Scan...", total=None)
        scan_results = []
        for result in scanner.scan_downloads():
            # Filtrer selon filter_type
            if filter_type == MediaFilter.MOVIES and result.detected_type != MediaType.MOVIE:
                continue
            if filter_type == MediaFilter.SERIES and result.detected_type != MediaType.SERIES:
                continue
            scan_results.append(result)
            progress.update(scan_task, description=f"[cyan]{result.video_file.filename}")
        progress.update(scan_task, total=len(scan_results), completed=len(scan_results))

    console.print(f"[bold]{len(scan_results)}[/bold] fichier(s) trouve(s)")

    # 3. Matching avec Progress
    pending_repo = container.pending_validation_repository()
    with Progress(...) as progress:
        match_task = progress.add_task("[green]Matching...", total=len(scan_results))
        for result in scan_results:
            # Creer PendingValidation
            # Rechercher candidats via TMDB/TVDB selon le type
            # Scorer les resultats
            # Sauvegarder en DB
            progress.advance(match_task)

    # 4. Auto-validation
    pending_list = validation_svc.list_pending()
    auto_count = 0
    for pending in pending_list:
        result = await validation_svc.process_auto_validation(pending)
        if result.auto_validated:
            auto_count += 1
    console.print(f"[bold]{auto_count}[/bold] fichier(s) auto-valide(s)")

    # 5. Validation interactive pour les restants
    remaining = [p for p in validation_svc.list_pending()
                 if p.validation_status == ValidationStatus.PENDING and not p.auto_validated]
    if remaining and not dry_run:
        console.print(f"\n[bold]{len(remaining)}[/bold] fichier(s) necessitent validation manuelle")
        # Utiliser validation_loop existant
        ...

    # 6. Batch transfer (si pas dry_run)
    if not dry_run:
        validated = validation_svc.list_validated()
        if validated:
            # Reutiliser la logique de validate_batch
            ...
    else:
        console.print("[yellow]Mode dry-run - aucun transfert effectue[/yellow]")

    # 7. Resume final
    console.print("\n[bold]Resume:[/bold]")
    console.print(f"  Scannes: {len(scan_results)}")
    console.print(f"  Auto-valides: {auto_count}")
    console.print(f"  Valides manuellement: {len(validated)}")
```

3. Commande pending:
```python
@app.command()
def pending(
    all_files: Annotated[bool, typer.Option("--all", "-a",
        help="Afficher tous les fichiers sans pagination")] = False,
) -> None:
    """Affiche les fichiers en attente de validation."""
    asyncio.run(_pending_async(all_files))

async def _pending_async(all_files: bool) -> None:
    container = Container()
    await container.database.init()
    validation_svc = container.validation_service()

    pending_list = validation_svc.list_pending()

    if not pending_list:
        console.print("[yellow]Aucun fichier en attente.[/yellow]")
        raise typer.Exit(0)

    # Tri par score decroissant
    def get_max_score(p):
        if not p.candidates:
            return 0
        return max(
            (c.get("score", 0) if isinstance(c, dict) else c.score
             for c in p.candidates),
            default=0
        )
    pending_list.sort(key=get_max_score, reverse=True)

    # Affichage avec panels Rich
    page_size = len(pending_list) if all_files else 15
    for pending in pending_list[:page_size]:
        panel = _render_pending_panel(pending)
        console.print(panel)

    if not all_files and len(pending_list) > page_size:
        console.print(f"\n[dim]({len(pending_list) - page_size} fichiers non affiches, utilisez --all)[/dim]")

    console.print(f"\n[bold]Total: {len(pending_list)} fichier(s) en attente[/bold]")

def _render_pending_panel(pending: PendingValidation) -> Panel:
    """Cree un panel Rich pour un fichier pending."""
    lines = []

    # Nom du fichier
    filename = pending.video_file.filename if pending.video_file else "?"
    lines.append(f"[bold cyan]{filename}[/bold cyan]")

    # Meilleur candidat
    if pending.candidates:
        best = pending.candidates[0]
        title = best.get("title", "") if isinstance(best, dict) else best.title
        score = best.get("score", 0) if isinstance(best, dict) else best.score
        score_color = "green" if score >= 85 else "yellow"
        lines.append(f"Meilleur: {title} ([{score_color}]{score:.0f}%[/{score_color}])")
        lines.append(f"Candidats: {len(pending.candidates)}")
    else:
        lines.append("[red]Aucun candidat[/red]")

    return Panel("\n".join(lines), border_style="white")
```

4. Dans main.py, ajouter les imports et les commandes:
```python
from src.adapters.cli.commands import validate_app, process, pending

# Ajouter comme commandes directes
app.command()(process)
app.command()(pending)
```

Note: Reutiliser au maximum les fonctions existantes de validation.py (console, Progress, display_batch_summary, execute_batch_transfer).
  </action>
  <verify>
```bash
python -m src.main process --help
# Doit montrer --filter/-f, --dry-run

python -m src.main pending --help
# Doit montrer --all/-a

# Test dry-run (ne modifie rien)
python -m src.main process --dry-run --filter movies
```
  </verify>
  <done>
- La commande process orchestre le workflow complet avec progression Rich
- La commande pending affiche les fichiers en attente avec panels
- Le mode dry-run fonctionne sans toucher aux fichiers
- Le filtrage par type de media fonctionne
  </done>
</task>

<task type="auto">
  <name>Task 3: Implementer validate file, etendre repo/service, et tests complets</name>
  <files>
    src/infrastructure/persistence/repositories/pending_validation_repository.py,
    src/services/validation.py,
    src/adapters/cli/commands.py,
    tests/unit/adapters/cli/test_commands.py
  </files>
  <action>
1. Ajouter methode get_by_id dans pending_validation_repository.py:
```python
def get_by_id(self, pending_id: str) -> Optional[PendingValidation]:
    """Recupere une validation en attente par son ID."""
    from sqlmodel import select
    statement = select(PendingValidationModel).where(
        PendingValidationModel.id == pending_id
    )
    model = self._session.exec(statement).first()
    return self._to_entity(model) if model else None
```

2. Ajouter methode get_pending_by_id dans validation.py (service):
```python
def get_pending_by_id(self, pending_id: str) -> Optional[PendingValidation]:
    """Recupere une validation en attente par son ID."""
    return self._pending_repo.get_by_id(pending_id)
```

3. Ajouter commande validate file dans commands.py (sous validate_app):
```python
@validate_app.command("file")
def validate_file(
    file_id: Annotated[str, typer.Argument(help="ID du fichier a valider")],
) -> None:
    """Valide un fichier specifique par son ID."""
    asyncio.run(_validate_file_async(file_id))

async def _validate_file_async(file_id: str) -> None:
    container = Container()
    await container.database.init()
    validation_svc = container.validation_service()

    # Chercher le pending par ID
    pending = validation_svc.get_pending_by_id(file_id)

    if pending is None:
        console.print(f"[red]Erreur:[/red] Fichier non trouve: {file_id}")
        raise typer.Exit(code=1)

    # Lancer la boucle de validation interactive
    result = await validation_loop(pending, validation_svc)

    if result == "quit":
        console.print("[yellow]Validation annulee.[/yellow]")
    elif result == "trash":
        validation_svc.reject_pending(pending)
        console.print("[red]Fichier mis en corbeille.[/red]")
    elif result is None:
        console.print("[yellow]Fichier passe.[/yellow]")
    else:
        # Valide avec le candidat selectionne
        console.print(f"[green]Fichier valide.[/green]")
```

**Choix de nomenclature (resolu):** La commande est `validate file <ID>` (sous-commande de validate_app), PAS une commande directe. Cela evite le conflit avec validate_app. L'utilisateur appelle:
- `cineorg validate auto` - auto-validation
- `cineorg validate manual` - validation manuelle interactive
- `cineorg validate batch` - batch transfer
- `cineorg validate file <ID>` - validation d'un fichier specifique

4. Ecrire les tests complets dans test_commands.py:

**Tests process:**
```python
def test_process_dry_run_no_files(monkeypatch, tmp_path):
    """process --dry-run sans fichiers affiche message."""
    # Setup: Container mock avec scanner vide

def test_process_filters_movies_only(monkeypatch, tmp_path):
    """process --filter movies ignore les series."""

def test_process_filters_series_only(monkeypatch, tmp_path):
    """process --filter series ignore les films."""

def test_process_full_workflow(monkeypatch, tmp_path):
    """process execute le workflow complet."""

def test_process_api_error_handling(monkeypatch, tmp_path):
    """process gere les erreurs API (TMDB/TVDB down)."""
    # Mock: TMDB client raise HTTPError
    # Verify: Message d'erreur affiche, pas de crash

def test_process_dry_run_no_file_modification(monkeypatch, tmp_path):
    """process --dry-run ne touche pas aux fichiers reels."""
    # Setup: Fichier temoin dans tmp_path
    # Run: process --dry-run
    # Verify: Fichier temoin intact, pas de symlinks crees
```

**Tests pending:**
```python
def test_pending_empty_list():
    """pending sans fichiers affiche message."""

def test_pending_shows_files_sorted_by_score():
    """pending trie par score decroissant."""

def test_pending_pagination_default():
    """pending affiche max 15 fichiers par defaut."""

def test_pending_all_option():
    """pending --all affiche tous les fichiers."""

def test_pending_database_error(monkeypatch):
    """pending gere les erreurs de base de donnees."""
    # Mock: validation_svc.list_pending raise OperationalError
    # Verify: Message d'erreur, exit code != 0
```

**Tests validate file:**
```python
def test_validate_file_not_found():
    """validate file avec ID inexistant retourne erreur."""

def test_validate_file_success():
    """validate file avec ID valide lance la boucle."""

def test_validate_file_concurrent_access(monkeypatch):
    """validate file gere l'acces concurrent (fichier deja traite)."""
    # Mock: get_pending_by_id retourne pending avec status != PENDING
    # Verify: Message d'avertissement, comportement gracieux
```

Utiliser les memes patterns de mock que test_validation.py existant.
  </action>
  <verify>
```bash
pytest tests/unit/adapters/cli/test_commands.py -v
# Tous les tests doivent passer

python -m src.main validate file --help
# Doit montrer file_id comme argument

python -m src.main validate --help
# Doit lister: auto, manual, batch, file
```
  </verify>
  <done>
- La commande `validate file <ID>` permet de valider un fichier par ID
- Le repository a la methode get_by_id
- Le service expose get_pending_by_id
- Tests couvrent les nouvelles commandes (process, pending, validate file)
- Tests incluent cas d'erreur critiques: API errors, DB errors, dry-run verification, concurrent access
- Tous les tests passent
  </done>
</task>

</tasks>

<verification>
Verification globale apres toutes les taches:

```bash
# Tests
pytest tests/unit/adapters/cli/ -v
pytest tests/ -v --cov=src --cov-report=term-missing

# CLI
python -m src.main --help
python -m src.main process --help
python -m src.main pending --help
python -m src.main validate --help
python -m src.main validate file --help

# Workflow complet (dry-run)
python -m src.main process --dry-run
```
</verification>

<success_criteria>
- [ ] Options --verbose/-v et --quiet/-q disponibles globalement
- [ ] Commande process orchestre scan -> matching -> validation -> transfert
- [ ] Commande pending affiche les fichiers en attente avec panels Rich
- [ ] Commande `validate file <ID>` permet de valider un fichier par ID
- [ ] Mode --dry-run simule sans modifier les fichiers (verifie par test)
- [ ] Filtrage --filter movies/series/all fonctionne
- [ ] Gestion des erreurs API (TMDB/TVDB) sans crash
- [ ] Gestion des erreurs DB sans crash
- [ ] Tous les tests passent
- [ ] Couverture >= 90%
</success_criteria>

<output>
After completion, create `.planning/phases/07-cli-principale/07-01-SUMMARY.md`
</output>
