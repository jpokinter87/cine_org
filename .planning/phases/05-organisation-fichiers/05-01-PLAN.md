---
phase: 05-organisation-fichiers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/renamer.py
  - src/services/organizer.py
  - src/services/quality_scorer.py
  - tests/unit/services/test_renamer.py
  - tests/unit/services/test_organizer.py
  - tests/unit/services/test_quality_scorer.py
autonomous: true

must_haves:
  truths:
    - "Les noms de fichiers generes suivent le format Titre (Annee) Langue Codec Resolution.ext"
    - "Les caracteres speciaux sont remplaces par des tirets"
    - "Les ligatures francaises (oe, ae) sont normalisees"
    - "La lettre de tri ignore les articles (Le, The, Der)"
    - "Les titres numeriques sont classes sous #"
    - "Le scoring qualite classe correctement les fichiers par resolution/codec/audio"
  artifacts:
    - path: "src/services/renamer.py"
      provides: "RenamerService avec generation noms standardises"
      exports: ["RenamerService", "sanitize_for_filesystem", "format_language_code"]
    - path: "src/services/organizer.py"
      provides: "OrganizerService avec calcul chemins destination"
      exports: ["OrganizerService", "get_sort_letter", "SubdivisionRange"]
    - path: "src/services/quality_scorer.py"
      provides: "QualityScorerService avec scoring multi-criteres"
      exports: ["QualityScorerService", "QualityScore", "calculate_quality_score"]
  key_links:
    - from: "src/services/renamer.py"
      to: "src/core/entities/media.py"
      via: "import Movie, Series, Episode"
      pattern: "from src\\.core\\.entities\\.media import"
    - from: "src/services/renamer.py"
      to: "src/core/value_objects/media_info.py"
      via: "import MediaInfo"
      pattern: "from src\\.core\\.value_objects import MediaInfo"
    - from: "src/services/organizer.py"
      to: "src/utils/constants.py"
      via: "import IGNORED_ARTICLES, GENRE_HIERARCHY"
      pattern: "from src\\.utils\\.constants import"
---

<objective>
Implementer les services de generation de noms de fichiers et de calcul des chemins de destination.

Purpose: Creer la logique pure (sans I/O) pour le renommage et l'organisation. Ces services seront utilises par le TransfererService dans Plan 02.

Output:
- RenamerService : genere les noms standardises (Titre (Annee) Langue Codec Resolution.ext)
- OrganizerService : calcule les chemins destination (Films/Genre/Lettre/, Series/Lettre/Titre/Saison XX/)
- QualityScorerService : evalue la qualite video pour comparer les doublons
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-organisation-fichiers/05-CONTEXT.md
@.planning/phases/05-organisation-fichiers/05-RESEARCH.md

# Code existant a utiliser
@src/core/entities/media.py
@src/core/value_objects/media_info.py
@src/utils/constants.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RenamerService avec sanitisation et formatage</name>
  <files>
    src/services/renamer.py
    tests/unit/services/test_renamer.py
  </files>
  <action>
Creer RenamerService avec TDD (tests d'abord, puis implementation).

**Tests a ecrire d'abord (test_renamer.py):**
```python
# Test sanitize_for_filesystem
def test_sanitize_replaces_special_chars_with_dash():
    assert sanitize_for_filesystem("Test: Subtitle") == "Test- Subtitle"
    assert sanitize_for_filesystem('Film "Quoted"') == "Film -Quoted-"
    assert sanitize_for_filesystem("Path/To\\File") == "Path-To-File"

def test_sanitize_replaces_question_mark_with_ellipsis():
    assert sanitize_for_filesystem("What?") == "What..."
    assert sanitize_for_filesystem("Who? Why?") == "Who... Why..."

def test_sanitize_normalizes_french_ligatures():
    assert sanitize_for_filesystem("Coeur") == "Coeur"  # oe -> oe
    assert sanitize_for_filesystem("Soeur") == "Soeur"  # sans ligature
    assert "oe" in sanitize_for_filesystem("Soeur")  # avec ligature oe
    # Note: utiliser \u0153 pour oe et \u00e6 pour ae

def test_sanitize_truncates_long_names():
    long_name = "A" * 250
    result = sanitize_for_filesystem(long_name)
    assert len(result) <= 200

# Test format_language_code
def test_format_language_single_code():
    assert format_language_code(("fr",)) == "FR"
    assert format_language_code(("en",)) == "EN"

def test_format_language_multiple_codes():
    assert format_language_code(("fr", "en")) == "MULTi"
    assert format_language_code(("fr", "en", "de")) == "MULTi"

def test_format_language_empty():
    assert format_language_code(()) == ""

# Test generate_movie_filename
def test_generate_movie_filename_complete(movie_fixture, media_info_fixture):
    result = generate_movie_filename(movie, media_info, ".mkv")
    assert result == "Matrix (1999) FR HEVC 1080p.mkv"

def test_generate_movie_filename_missing_year():
    movie = Movie(title="Inception")
    result = generate_movie_filename(movie, None, ".mp4")
    assert result == "Inception.mp4"

# Test generate_series_filename
def test_generate_series_filename_complete():
    series = Series(title="Breaking Bad", year=2008)
    episode = Episode(season_number=1, episode_number=1, title="Pilot")
    result = generate_series_filename(series, episode, media_info, ".mkv")
    assert result == "Breaking Bad (2008) - S01E01 - Pilot - FR HEVC 1080p.mkv"
```

**Implementation (renamer.py):**
- `sanitize_for_filesystem(text: str) -> str` : nettoie les caracteres speciaux
  - Normalisation NFKC Unicode
  - Remplacement ligatures (oe -> oe, ae -> ae, OE -> Oe, AE -> Ae)
  - Caracteres : / \ * " < > | -> tiret
  - ? -> ...
  - Troncature a 200 caracteres
  - Utiliser pathvalidate.sanitize_filename(platform='universal')

- `format_language_code(languages: tuple[str, ...]) -> str` : formate codes langue
  - Vide -> ""
  - Une langue -> code ISO majuscule (FR, EN)
  - Plusieurs langues -> "MULTi"

- `generate_movie_filename(movie: Movie, media_info: MediaInfo, extension: str) -> str`
  - Format: Titre (Annee) Langue Codec Resolution.ext
  - Chaque element optionnel omis si absent

- `generate_series_filename(series: Series, episode: Episode, media_info: MediaInfo, extension: str) -> str`
  - Format: Titre (Annee) - SxxExx - TitreEpisode - Langue Codec Resolution.ext

**Dependance:** Installer pathvalidate (`pip install pathvalidate` ou ajouter a requirements.txt)
  </action>
  <verify>
```bash
pytest tests/unit/services/test_renamer.py -v
```
Tous les tests passent.
  </verify>
  <done>
- sanitize_for_filesystem gere tous les caracteres speciaux et ligatures
- format_language_code retourne le bon format selon le nombre de langues
- generate_movie_filename produit "Titre (Annee) Langue Codec Resolution.ext"
- generate_series_filename produit "Titre (Annee) - SxxExx - Episode - Langue Codec Resolution.ext"
  </done>
</task>

<task type="auto">
  <name>Task 2: OrganizerService avec calcul chemins et subdivision</name>
  <files>
    src/services/organizer.py
    tests/unit/services/test_organizer.py
  </files>
  <action>
Creer OrganizerService avec TDD.

**Tests a ecrire d'abord (test_organizer.py):**
```python
# Test get_sort_letter
def test_sort_letter_ignores_french_articles():
    assert get_sort_letter("Le Parrain") == "P"
    assert get_sort_letter("La Guerre des Etoiles") == "G"
    assert get_sort_letter("Les Miserables") == "M"
    assert get_sort_letter("L'Odyssee") == "O"

def test_sort_letter_ignores_english_articles():
    assert get_sort_letter("The Matrix") == "M"
    assert get_sort_letter("A Beautiful Mind") == "B"
    assert get_sort_letter("An Officer") == "O"

def test_sort_letter_ignores_german_articles():
    assert get_sort_letter("Der Untergang") == "U"
    assert get_sort_letter("Die Hard") == "H"  # Ici Die est article allemand

def test_sort_letter_numeric_titles():
    assert get_sort_letter("2001 A Space Odyssey") == "#"
    assert get_sort_letter("12 Angry Men") == "#"
    assert get_sort_letter("300") == "#"

def test_sort_letter_special_start():
    assert get_sort_letter("...And Justice for All") == "#"

# Test get_priority_genre
def test_priority_genre_follows_hierarchy():
    assert get_priority_genre(("Action", "Drame")) == "Action"
    assert get_priority_genre(("Drame", "Action")) == "Action"  # Action prioritaire
    assert get_priority_genre(("Animation", "Action")) == "Animation"  # Animation > Action
    assert get_priority_genre(("Science-Fiction", "Horreur")) == "Science-Fiction"

def test_priority_genre_unknown_returns_divers():
    assert get_priority_genre(()) == "Divers"
    assert get_priority_genre(("Unknown",)) == "Unknown"  # Si seul genre, le garder

# Test get_movie_destination
def test_movie_destination_structure():
    movie = Movie(title="Matrix", year=1999, genres=("Science-Fiction", "Action"))
    path = get_movie_destination(movie, Path("/storage"))
    assert path == Path("/storage/Films/Science-Fiction/M")

def test_movie_destination_with_article():
    movie = Movie(title="Le Parrain", year=1972, genres=("Crime", "Drame"))
    path = get_movie_destination(movie, Path("/storage"))
    assert path == Path("/storage/Films/Crime/P")

# Test get_series_destination
def test_series_destination_structure():
    series = Series(title="Breaking Bad", year=2008)
    path = get_series_destination(series, season_number=1, storage_dir=Path("/storage"))
    assert path == Path("/storage/Series/B/Breaking Bad (2008)/Saison 01")

def test_series_destination_with_article():
    series = Series(title="The Wire", year=2002)
    path = get_series_destination(series, season_number=3, storage_dir=Path("/storage"))
    assert path == Path("/storage/Series/W/The Wire (2002)/Saison 03")
```

**Implementation (organizer.py):**
- `get_sort_letter(title: str) -> str`
  - Ignorer les articles (IGNORED_ARTICLES de constants.py)
  - Gerer l'apostrophe (L'Odyssee -> Odyssee)
  - Retourner "#" pour les titres numeriques ou speciaux

- `get_priority_genre(genres: tuple[str, ...]) -> str`
  - Suivre GENRE_HIERARCHY de constants.py
  - Retourner "Divers" si vide

- `get_movie_destination(movie: Movie, storage_dir: Path) -> Path`
  - Structure: stockage/Films/Genre/Lettre/
  - Genre = premier genre prioritaire
  - Lettre = get_sort_letter(title)

- `get_series_destination(series: Series, season_number: int, storage_dir: Path) -> Path`
  - Structure: stockage/Series/Lettre/Titre (Annee)/Saison XX/
  - Format saison: "Saison 01", "Saison 02", etc.

- `SubdivisionRange` dataclass avec start, end, label property (pour Phase 8 - subdivision dynamique)
  </action>
  <verify>
```bash
pytest tests/unit/services/test_organizer.py -v
```
Tous les tests passent.
  </verify>
  <done>
- get_sort_letter ignore tous les articles fr/en/de/es
- get_sort_letter retourne "#" pour les titres numeriques
- get_priority_genre suit la hierarchie GENRE_HIERARCHY
- get_movie_destination retourne stockage/Films/Genre/Lettre
- get_series_destination retourne stockage/Series/Lettre/Titre (Annee)/Saison XX
  </done>
</task>

<task type="auto">
  <name>Task 3: QualityScorerService avec scoring multi-criteres</name>
  <files>
    src/services/quality_scorer.py
    tests/unit/services/test_quality_scorer.py
  </files>
  <action>
Creer QualityScorerService avec TDD.

**Tests a ecrire d'abord (test_quality_scorer.py):**
```python
# Test score_resolution
def test_resolution_score_4k():
    res = Resolution(width=3840, height=2160)
    assert score_resolution(res) == 100

def test_resolution_score_1080p():
    res = Resolution(width=1920, height=1080)
    assert score_resolution(res) == 75

def test_resolution_score_720p():
    res = Resolution(width=1280, height=720)
    assert score_resolution(res) == 50

def test_resolution_score_sd():
    res = Resolution(width=720, height=480)
    assert score_resolution(res) == 25

def test_resolution_score_none():
    assert score_resolution(None) == 0

# Test score_video_codec
def test_video_codec_score_av1():
    codec = VideoCodec(name="AV1")
    assert score_video_codec(codec) == 100

def test_video_codec_score_hevc():
    codec = VideoCodec(name="HEVC")
    assert score_video_codec(codec) == 85
    codec2 = VideoCodec(name="H.265")
    assert score_video_codec(codec2) == 85

def test_video_codec_score_h264():
    codec = VideoCodec(name="H.264")
    assert score_video_codec(codec) == 60

def test_video_codec_score_unknown():
    codec = VideoCodec(name="UNKNOWN")
    assert score_video_codec(codec) == 30  # Score par defaut

# Test score_audio
def test_audio_score_truehd_71():
    codecs = (AudioCodec(name="TrueHD", channels="7.1"),)
    score = score_audio(codecs)
    assert score > 90  # Excellent

def test_audio_score_dts_51():
    codecs = (AudioCodec(name="DTS", channels="5.1"),)
    score = score_audio(codecs)
    assert 60 < score < 80

def test_audio_score_aac_stereo():
    codecs = (AudioCodec(name="AAC", channels="2.0"),)
    score = score_audio(codecs)
    assert score < 60

# Test calculate_quality_score total
def test_quality_score_high_quality():
    media_info = MediaInfo(
        resolution=Resolution(3840, 2160),
        video_codec=VideoCodec(name="HEVC"),
        audio_codecs=(AudioCodec(name="TrueHD", channels="7.1"),),
    )
    score = calculate_quality_score(media_info, file_size_bytes=10_000_000_000, duration_seconds=7200)
    assert score.total > 80

def test_quality_score_low_quality():
    media_info = MediaInfo(
        resolution=Resolution(720, 480),
        video_codec=VideoCodec(name="XVID"),
        audio_codecs=(AudioCodec(name="MP3", channels="2.0"),),
    )
    score = calculate_quality_score(media_info, file_size_bytes=700_000_000, duration_seconds=5400)
    assert score.total < 50

def test_quality_score_none_media_info():
    score = calculate_quality_score(None, file_size_bytes=0)
    assert score.total == 0
```

**Implementation (quality_scorer.py):**
- `QualityScore` dataclass frozen avec:
  - resolution_score: float (0-100)
  - video_codec_score: float (0-100)
  - bitrate_score: float (0-100)
  - audio_score: float (0-100)
  - size_efficiency: float (0-100)
  - total: float (score pondere)
  - breakdown property pour affichage lisible

- `score_resolution(resolution: Resolution | None) -> float`
  - 4K (>=2160): 100
  - 1080p (>=1080): 75
  - 720p (>=720): 50
  - SD: 25
  - None: 0

- `score_video_codec(codec: VideoCodec | None) -> float`
  - AV1: 100
  - HEVC/H.265: 85
  - VP9: 70
  - H.264: 60
  - Autres: 30

- `score_audio(codecs: tuple[AudioCodec, ...]) -> float`
  - Combine codec score (70%) + channels score (30%)
  - TrueHD/Atmos: 100, DTS-HD: 90, DTS: 70, AC3: 60, AAC: 55, MP3: 40
  - 7.1: 100, 5.1: 75, 2.0: 50, 1.0: 25

- `calculate_quality_score(media_info: MediaInfo | None, file_size_bytes: int, duration_seconds: int | None = None) -> QualityScore`
  - Poids: resolution 30%, codec 25%, bitrate 20%, audio 15%, taille 10%
  </action>
  <verify>
```bash
pytest tests/unit/services/test_quality_scorer.py -v
```
Tous les tests passent.
  </verify>
  <done>
- score_resolution classe correctement 4K > 1080p > 720p > SD
- score_video_codec classe correctement AV1 > HEVC > H.264 > anciens
- score_audio combine codec et canaux (7.1 > 5.1 > stereo)
- calculate_quality_score retourne un score pondere total
- QualityScore.breakdown affiche le detail lisible
  </done>
</task>

</tasks>

<verification>
```bash
# Tous les tests des 3 services
pytest tests/unit/services/test_renamer.py tests/unit/services/test_organizer.py tests/unit/services/test_quality_scorer.py -v

# Verification coverage
pytest tests/unit/services/ --cov=src/services --cov-report=term-missing

# Verification imports
python -c "from src.services.renamer import RenamerService, sanitize_for_filesystem, format_language_code, generate_movie_filename, generate_series_filename; print('Renamer OK')"
python -c "from src.services.organizer import OrganizerService, get_sort_letter, get_priority_genre, get_movie_destination, get_series_destination; print('Organizer OK')"
python -c "from src.services.quality_scorer import QualityScorerService, QualityScore, calculate_quality_score, score_resolution, score_video_codec, score_audio; print('QualityScorer OK')"
```
</verification>

<success_criteria>
1. RenamerService genere des noms de fichiers au format standardise
2. Les caracteres speciaux et ligatures sont correctement traites
3. OrganizerService calcule les chemins Films/Genre/Lettre et Series/Lettre/Titre/Saison
4. Les articles sont ignores pour le tri alphabetique
5. QualityScorerService score correctement resolution, codec, audio
6. Tous les tests passent avec coverage >= 90%
</success_criteria>

<output>
Apres completion, creer `.planning/phases/05-organisation-fichiers/05-01-SUMMARY.md`
</output>
