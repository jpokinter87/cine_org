---
phase: 05-organisation-fichiers
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/services/transferer.py
  - src/adapters/file_system.py
  - src/container.py
  - requirements.txt
  - tests/unit/services/test_transferer.py
autonomous: true

must_haves:
  truths:
    - "Les fichiers sont deplaces de maniere atomique vers leur destination"
    - "Les symlinks relatifs sont crees dans video/ pointant vers stockage/"
    - "Les conflits de fichiers sont detectes via hash avant ecrasement"
    - "Un rollback est effectue en cas d'erreur pendant le transfert"
    - "Les services sont disponibles via le container DI"
  artifacts:
    - path: "src/services/transferer.py"
      provides: "TransfererService avec move atomique et symlinks"
      exports: ["TransfererService", "TransferResult", "ConflictInfo", "ConflictType"]
    - path: "src/adapters/file_system.py"
      provides: "FileSystemAdapter etendu avec atomic_move"
      min_lines: 200
    - path: "src/container.py"
      provides: "Container DI avec nouveaux services"
      contains: "renamer_service"
  key_links:
    - from: "src/services/transferer.py"
      to: "src/core/ports/file_system.py"
      via: "import IFileSystem, ISymlinkManager"
      pattern: "from src\\.core\\.ports\\.file_system import"
    - from: "src/services/transferer.py"
      to: "src/infrastructure/persistence/hash_service.py"
      via: "import compute_file_hash"
      pattern: "from src\\.infrastructure\\.persistence\\.hash_service import"
    - from: "src/services/transferer.py"
      to: "src/services/organizer.py"
      via: "calcul chemins destination"
      pattern: "from src\\.services\\.organizer import"
    - from: "src/container.py"
      to: "src/services/renamer.py"
      via: "providers.Singleton"
      pattern: "RenamerService"
---

<objective>
Implementer le service de transfert atomique avec gestion des conflits et creation des symlinks.

Purpose: Fournir un transfert de fichiers fiable avec detection des doublons, move atomique, creation de symlinks relatifs, et rollback en cas d'erreur.

Output:
- TransfererService : transfert atomique avec check_conflict, transfer_file, create_symlink
- FileSystemAdapter etendu avec atomic_move
- Integration complete au container DI
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-organisation-fichiers/05-CONTEXT.md
@.planning/phases/05-organisation-fichiers/05-RESEARCH.md
@.planning/phases/05-organisation-fichiers/05-01-SUMMARY.md

# Code existant
@src/core/ports/file_system.py
@src/adapters/file_system.py
@src/infrastructure/persistence/hash_service.py
@src/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TransfererService avec move atomique et gestion conflits</name>
  <files>
    src/services/transferer.py
    src/adapters/file_system.py
    tests/unit/services/test_transferer.py
  </files>
  <action>
Creer TransfererService avec TDD et etendre FileSystemAdapter.

**Tests a ecrire d'abord (test_transferer.py):**
```python
import pytest
from pathlib import Path
from unittest.mock import Mock, patch
from src.services.transferer import (
    TransfererService, TransferResult, ConflictInfo, ConflictType
)

@pytest.fixture
def mock_file_system():
    return Mock()

@pytest.fixture
def mock_symlink_manager():
    return Mock()

@pytest.fixture
def transferer(mock_file_system, mock_symlink_manager, tmp_path):
    return TransfererService(
        file_system=mock_file_system,
        symlink_manager=mock_symlink_manager,
        storage_dir=tmp_path / "storage",
        video_dir=tmp_path / "video",
    )

# Test check_conflict
def test_check_conflict_no_existing_file(transferer, mock_file_system):
    mock_file_system.exists.return_value = False
    result = transferer.check_conflict(Path("/src/file.mkv"), Path("/dst/file.mkv"))
    assert result is None

def test_check_conflict_same_hash_is_duplicate(transferer, mock_file_system):
    mock_file_system.exists.return_value = True
    with patch("src.services.transferer.compute_file_hash") as mock_hash:
        mock_hash.side_effect = ["abc123", "abc123"]  # Same hash
        result = transferer.check_conflict(Path("/src/file.mkv"), Path("/dst/file.mkv"))
        assert result is not None
        assert result.conflict_type == ConflictType.DUPLICATE

def test_check_conflict_different_hash_is_collision(transferer, mock_file_system):
    mock_file_system.exists.return_value = True
    with patch("src.services.transferer.compute_file_hash") as mock_hash:
        mock_hash.side_effect = ["abc123", "xyz789"]  # Different hash
        result = transferer.check_conflict(Path("/src/file.mkv"), Path("/dst/file.mkv"))
        assert result is not None
        assert result.conflict_type == ConflictType.NAME_COLLISION

# Test transfer_file (integration avec fichiers reels)
def test_transfer_file_success(tmp_path):
    # Setup real files
    storage = tmp_path / "storage" / "Films"
    video = tmp_path / "video" / "Films"
    storage.mkdir(parents=True)
    video.mkdir(parents=True)

    source = tmp_path / "downloads" / "movie.mkv"
    source.parent.mkdir(parents=True)
    source.write_bytes(b"fake video content")

    dest = storage / "Action" / "M" / "Matrix.mkv"

    # Real adapters
    from src.adapters.file_system import FileSystemAdapter
    fs = FileSystemAdapter()
    transferer = TransfererService(fs, fs, storage.parent, video.parent)

    result = transferer.transfer_file(source, dest, create_symlink=True)

    assert result.success
    assert result.final_path == dest
    assert dest.exists()
    assert not source.exists()  # Source moved

def test_transfer_file_with_conflict_returns_failure(transferer, mock_file_system):
    mock_file_system.exists.return_value = True
    with patch("src.services.transferer.compute_file_hash") as mock_hash:
        mock_hash.side_effect = ["abc", "xyz"]  # Different = conflict
        result = transferer.transfer_file(Path("/src"), Path("/dst"))
        assert not result.success
        assert result.conflict is not None

# Test create_relative_symlink
def test_create_relative_symlink(tmp_path):
    storage = tmp_path / "storage" / "Films" / "Action" / "M"
    video = tmp_path / "video" / "Films" / "Action" / "M"
    storage.mkdir(parents=True)
    video.mkdir(parents=True)

    target = storage / "Matrix.mkv"
    target.write_bytes(b"content")

    from src.adapters.file_system import FileSystemAdapter
    fs = FileSystemAdapter()
    transferer = TransfererService(fs, fs, tmp_path / "storage", tmp_path / "video")

    symlink = transferer._create_mirror_symlink(target)

    assert symlink.is_symlink()
    assert symlink.resolve() == target
    # Verifier que c'est un chemin relatif
    assert ".." in str(symlink.readlink())
```

**Etendre FileSystemAdapter (file_system.py):**
Ajouter methode `atomic_move(source: Path, destination: Path) -> bool`:
```python
def atomic_move(self, source: Path, destination: Path) -> bool:
    """
    Deplace un fichier de maniere atomique.

    Utilise os.replace pour meme filesystem, staged copy pour cross-filesystem.
    """
    import os
    import uuid

    try:
        destination.parent.mkdir(parents=True, exist_ok=True)

        # Tentative rename atomique (meme filesystem)
        try:
            os.replace(source, destination)
        except OSError:
            # Cross-filesystem: staged copy
            temp = destination.with_name(f".tmp_{uuid.uuid4().hex}_{destination.name}")
            shutil.copy2(source, temp)
            os.replace(temp, destination)
            source.unlink()

        return True
    except Exception:
        return False
```

**Implementation TransfererService (transferer.py):**
```python
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Optional
import os

from src.core.ports.file_system import IFileSystem, ISymlinkManager
from src.infrastructure.persistence.hash_service import compute_file_hash


class ConflictType(Enum):
    NONE = "none"
    DUPLICATE = "duplicate"  # Meme hash
    NAME_COLLISION = "name_collision"  # Meme nom, hash different


@dataclass
class ConflictInfo:
    conflict_type: ConflictType
    existing_path: Path
    existing_hash: str
    new_hash: str


@dataclass
class TransferResult:
    success: bool
    final_path: Optional[Path] = None
    symlink_path: Optional[Path] = None
    conflict: Optional[ConflictInfo] = None
    error: Optional[str] = None


class TransfererService:
    def __init__(
        self,
        file_system: IFileSystem,
        symlink_manager: ISymlinkManager,
        storage_dir: Path,
        video_dir: Path,
    ):
        self._fs = file_system
        self._symlinks = symlink_manager
        self._storage_dir = storage_dir
        self._video_dir = video_dir

    def check_conflict(self, source: Path, destination: Path) -> Optional[ConflictInfo]:
        """Verifie conflit avec fichier existant via hash."""
        if not self._fs.exists(destination):
            return None

        source_hash = compute_file_hash(source)
        dest_hash = compute_file_hash(destination)

        conflict_type = ConflictType.DUPLICATE if source_hash == dest_hash else ConflictType.NAME_COLLISION
        return ConflictInfo(
            conflict_type=conflict_type,
            existing_path=destination,
            existing_hash=dest_hash,
            new_hash=source_hash,
        )

    def transfer_file(
        self,
        source: Path,
        destination: Path,
        create_symlink: bool = True,
    ) -> TransferResult:
        """Transfere fichier avec atomicite et rollback."""
        # Verifier conflit
        conflict = self.check_conflict(source, destination)
        if conflict:
            return TransferResult(success=False, conflict=conflict)

        try:
            # Move atomique
            if not self._fs.atomic_move(source, destination):
                return TransferResult(success=False, error="Move failed")

            # Symlink
            symlink_path = None
            if create_symlink:
                symlink_path = self._create_mirror_symlink(destination)

            return TransferResult(
                success=True,
                final_path=destination,
                symlink_path=symlink_path,
            )
        except Exception as e:
            # Rollback: remettre le fichier si possible
            if not source.exists() and destination.exists():
                try:
                    self._fs.atomic_move(destination, source)
                except Exception:
                    pass
            return TransferResult(success=False, error=str(e))

    def _create_mirror_symlink(self, storage_path: Path) -> Path:
        """Cree symlink relatif dans video/ vers storage_path."""
        relative_to_storage = storage_path.relative_to(self._storage_dir)
        symlink_path = self._video_dir / relative_to_storage

        symlink_path.parent.mkdir(parents=True, exist_ok=True)

        # Chemin relatif (Python 3.11: utiliser os.path.relpath)
        target_relative = os.path.relpath(storage_path, symlink_path.parent)

        if symlink_path.exists() or symlink_path.is_symlink():
            symlink_path.unlink()
        symlink_path.symlink_to(target_relative)

        return symlink_path
```

**Note:** Utiliser `os.path.relpath` au lieu de `Path.relative_to(walk_up=True)` car walk_up n'existe qu'en Python 3.12.
  </action>
  <verify>
```bash
pytest tests/unit/services/test_transferer.py -v
```
Tous les tests passent.
  </verify>
  <done>
- ConflictType enum avec NONE, DUPLICATE, NAME_COLLISION
- TransfererService.check_conflict detecte doublons via hash
- TransfererService.transfer_file deplace avec atomicite et cree symlink
- _create_mirror_symlink cree des symlinks avec chemins relatifs
- FileSystemAdapter.atomic_move gere same-filesystem et cross-filesystem
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration DI container et mise a jour requirements</name>
  <files>
    src/container.py
    requirements.txt
  </files>
  <action>
Integrer les nouveaux services au container DI et ajouter pathvalidate aux dependances.

**Mise a jour requirements.txt:**
Ajouter apres la section existante:
```
# File Operations
pathvalidate>=3.2.0
```

**Mise a jour container.py:**
```python
# Ajouter imports en haut
from .services.renamer import RenamerService
from .services.organizer import OrganizerService
from .services.quality_scorer import QualityScorerService
from .services.transferer import TransfererService

# Dans la classe Container, ajouter:

    # Services de renommage et organisation
    renamer_service = providers.Singleton(RenamerService)
    organizer_service = providers.Singleton(OrganizerService)
    quality_scorer_service = providers.Singleton(QualityScorerService)

    # Service de transfert - necessite config pour paths
    transferer_service = providers.Factory(
        TransfererService,
        file_system=file_system,
        symlink_manager=file_system,  # FileSystemAdapter implemente les deux
        storage_dir=providers.Object(None),  # A configurer via settings
        video_dir=providers.Object(None),    # A configurer via settings
    )
```

**Note:** Les chemins storage_dir et video_dir seront configures dynamiquement lors de l'utilisation via settings.paths.storage et settings.paths.video.

Alternative plus propre avec factory function:
```python
def create_transferer_service(
    file_system: FileSystemAdapter,
    settings: Settings,
) -> TransfererService:
    return TransfererService(
        file_system=file_system,
        symlink_manager=file_system,
        storage_dir=Path(settings.paths_storage),
        video_dir=Path(settings.paths_video),
    )

# Dans Container:
transferer_service = providers.Factory(
    create_transferer_service,
    file_system=file_system,
    settings=config,
)
```

Choisir l'approche qui correspond le mieux a la structure existante du container.
  </action>
  <verify>
```bash
# Verifier l'installation
pip install pathvalidate>=3.2.0

# Verifier les imports
python -c "
from src.container import Container
c = Container()
print('RenamerService:', c.renamer_service)
print('OrganizerService:', c.organizer_service)
print('QualityScorerService:', c.quality_scorer_service)
print('TransfererService:', c.transferer_service)
print('All services OK')
"
```
  </verify>
  <done>
- pathvalidate>=3.2.0 ajoute a requirements.txt
- RenamerService disponible via container.renamer_service()
- OrganizerService disponible via container.organizer_service()
- QualityScorerService disponible via container.quality_scorer_service()
- TransfererService disponible via container.transferer_service()
  </done>
</task>

</tasks>

<verification>
```bash
# Tests complets Phase 5
pytest tests/unit/services/test_renamer.py tests/unit/services/test_organizer.py tests/unit/services/test_quality_scorer.py tests/unit/services/test_transferer.py -v

# Coverage
pytest tests/unit/services/ --cov=src/services --cov-report=term-missing

# Verification integration DI
python -c "
from src.container import Container
c = Container()
c.database.init()

# Verifier tous les services
renamer = c.renamer_service()
organizer = c.organizer_service()
scorer = c.quality_scorer_service()
# transferer necessite settings configures

print('Phase 5 services integration OK')
"

# Verification des exports
python -c "
from src.services.renamer import sanitize_for_filesystem, generate_movie_filename
from src.services.organizer import get_sort_letter, get_movie_destination, get_series_destination
from src.services.quality_scorer import calculate_quality_score, QualityScore
from src.services.transferer import TransfererService, TransferResult, ConflictType
print('All exports OK')
"
```
</verification>

<success_criteria>
1. TransfererService detecte les conflits via hash (doublons vs collisions)
2. Les fichiers sont deplaces de maniere atomique (os.replace + fallback staged copy)
3. Les symlinks sont crees avec chemins relatifs dans video/
4. Le rollback fonctionne en cas d'erreur
5. Tous les services sont disponibles via le container DI
6. pathvalidate est ajoute aux dependances
7. Tous les tests passent avec coverage >= 90%
</success_criteria>

<output>
Apres completion, creer `.planning/phases/05-organisation-fichiers/05-02-SUMMARY.md`
</output>
