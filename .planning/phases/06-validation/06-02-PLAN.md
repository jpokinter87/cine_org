---
phase: 06-validation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/adapters/cli/__init__.py
  - src/adapters/cli/validation.py
  - src/adapters/cli/commands.py
  - tests/unit/adapters/cli/test_validation.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "L'utilisateur voit les candidats affiches en cartes detaillees avec badge RECOMMANDE"
    - "L'utilisateur peut selectionner un candidat par numero (1, 2, 3...)"
    - "L'utilisateur peut passer, rechercher manuellement, saisir ID externe, ou mettre en corbeille"
    - "Le batch final affiche tous les fichiers valides avec destinations et demande confirmation"
    - "Le transfert affiche une barre de progression avec fichier en cours"
  artifacts:
    - path: "src/adapters/cli/validation.py"
      provides: "Interface CLI interactive de validation avec Rich"
      min_lines: 200
    - path: "src/adapters/cli/commands.py"
      provides: "Commandes Typer pour validation (auto, manual, batch)"
      exports: ["validate_app"]
    - path: "tests/unit/adapters/cli/test_validation.py"
      provides: "Tests CLI avec mocks pour les prompts"
      min_lines: 100
  key_links:
    - from: "src/adapters/cli/validation.py"
      to: "src/services/validation.py"
      via: "ValidationService pour la logique metier"
      pattern: "ValidationService|validation_service"
    - from: "src/adapters/cli/validation.py"
      to: "rich.panel"
      via: "Rich Panel pour affichage cartes candidats"
      pattern: "Panel|rich\\.panel"
    - from: "src/adapters/cli/commands.py"
      to: "src/adapters/cli/validation.py"
      via: "Import des fonctions d'affichage et boucle interactive"
      pattern: "validation_loop|display_candidates"
    - from: "src/adapters/cli/commands.py"
      to: "src/services/transferer.py"
      via: "TransfererService.transfer_file(source, destination, create_symlink)"
      pattern: "transferer_service|transfer_file"
    - from: "src/adapters/cli/commands.py"
      to: "src/services/renamer.py"
      via: "RenamerService.generate_movie_filename(movie, media_info, extension) ou generate_series_filename(series, episode, media_info, extension)"
      pattern: "renamer_service|generate_movie_filename|generate_series_filename"
    - from: "src/adapters/cli/commands.py"
      to: "src/services/organizer.py"
      via: "OrganizerService.get_movie_destination(movie, storage_dir) ou get_series_destination(series, season_number, storage_dir)"
      pattern: "organizer_service|get_movie_destination|get_series_destination"
---

<objective>
Creer l'interface CLI interactive de validation avec Rich pour affichage des candidats et barre de progression.

Purpose: Permettre a l'utilisateur de valider manuellement les fichiers ambigus avec une interface agreable.
Output: Module CLI avec commandes validate (auto, manual, batch) utilisant Rich pour l'affichage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-validation/06-RESEARCH.md
@.planning/phases/06-validation/06-CONTEXT.md
@.planning/phases/06-validation/06-01-SUMMARY.md
@src/services/validation.py
@src/services/transferer.py
@src/services/renamer.py
@src/services/organizer.py
@src/core/entities/video.py
@src/core/entities/media.py
@src/core/ports/api_clients.py
@src/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer le module d'affichage CLI validation</name>
  <files>src/adapters/cli/__init__.py, src/adapters/cli/validation.py</files>
  <action>
Creer le repertoire src/adapters/cli/ avec __init__.py vide si inexistant.

Creer src/adapters/cli/validation.py avec:

1. **Imports necessaires:**
   ```python
   import asyncio
   import re
   from rich.console import Console
   from rich.panel import Panel
   from rich.table import Table
   from rich.text import Text
   from rich.prompt import Prompt, Confirm
   from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn

   from src.core.entities.video import PendingValidation, ValidationStatus
   from src.core.ports.api_clients import SearchResult, MediaDetails
   from src.services.validation import ValidationService
   from src.services.transferer import TransferResult
   ```

2. **Console globale:**
   `console = Console()`

3. **Constantes:**
   ```python
   PAGE_SIZE = 5  # Nombre de candidats par page
   IMDB_PATTERN = re.compile(r"^tt\d{7,8}$", re.IGNORECASE)
   ```

4. **Classe CandidatePaginator:**
   ```python
   class CandidatePaginator:
       def __init__(self, candidates: list[SearchResult], page_size: int = PAGE_SIZE):
           self.candidates = candidates
           self.page_size = page_size
           self.current_page = 0

       @property
       def total_pages(self) -> int:
           return (len(self.candidates) + self.page_size - 1) // self.page_size

       @property
       def current_items(self) -> list[SearchResult]:
           start = self.current_page * self.page_size
           return self.candidates[start:start + self.page_size]

       def select(self, display_number: int) -> SearchResult | None:
           idx = (self.current_page * self.page_size) + display_number - 1
           if 0 <= idx < len(self.candidates):
               return self.candidates[idx]
           return None

       def next_page(self) -> bool:
           if self.current_page + 1 < self.total_pages:
               self.current_page += 1
               return True
           return False

       def has_more(self) -> bool:
           return self.current_page + 1 < self.total_pages
   ```

5. **Fonction render_candidate_card(candidate: SearchResult, rank: int, is_best: bool = False) -> Panel:**
   - Cree un Text avec: titre (bold), annee, score (vert si >= 85, jaune sinon), source
   - Ajoute genres tronques (3 max) si disponibles dans candidate (note: SearchResult n'a pas genres, ils viennent de MediaDetails - afficher seulement titre/annee/score/source)
   - Titre du Panel: "[rank]" avec "[bold green]* RECOMMANDE[/]" si is_best
   - Bordure verte si is_best, blanche sinon
   - Retourne le Panel

6. **Fonction display_candidates(paginator: CandidatePaginator, pending: PendingValidation):**
   - Affiche header avec nom du fichier (pending.video_file.filename)
   - Pour chaque candidat de paginator.current_items:
     - Appelle render_candidate_card(candidate, rank, is_best=(rank==1 et page==0))
     - console.print(panel)
   - Si paginator.has_more(): affiche "[dim]Autres candidats disponibles...[/]"

7. **Fonction display_help():**
   - Affiche les commandes disponibles: [1-5] selectionner, [s] passer, [t] corbeille, [r] rechercher, [i] ID externe, [d] details, [?] aide, [q] quitter

8. **Fonction detect_external_id(user_input: str) -> tuple[str | None, str | None]:**
   - Si IMDB_PATTERN.match(user_input): return ("imdb", user_input.lower())
   - Si user_input.isdigit(): return ("numeric", user_input)  # Caller demande tmdb/tvdb
   - Sinon: return (None, None)

9. **Fonction determine_is_series(pending: PendingValidation) -> bool:**
   **Logique de detection is_series:**
   ```python
   def determine_is_series(pending: PendingValidation) -> bool:
       """
       Determine si le fichier est une serie a partir de media_info.guessed.

       Priorite:
       1. Si media_info.guessed["type"] == "episode" -> True
       2. Si media_info.guessed["type"] == "movie" -> False
       3. Si type absent ou invalide -> False (defaut film)

       Returns:
           True si serie, False sinon (film par defaut)
       """
       if pending.video_file is None or pending.video_file.media_info is None:
           return False

       guessed = pending.video_file.media_info.guessed
       if guessed is None:
           return False

       media_type = guessed.get("type")
       if media_type == "episode":
           return True

       # Par defaut (movie, absent, ou autre) -> film
       return False
   ```

10. **Fonction async validation_loop(pending: PendingValidation, service: ValidationService) -> str | None:**
    - Cree un CandidatePaginator avec pending.candidates
    - Boucle while True:
      - display_candidates(paginator, pending)
      - choice = Prompt.ask("[bold]Choix[/]", default="1")
      - Si choice.isdigit() et 1 <= int(choice) <= len(paginator.current_items):
        - candidate = paginator.select(int(choice))
        - Afficher mini-recap avec destination proposee (titre (annee))
        - Si Confirm.ask("Valider ?"): return candidate.id
      - elif choice == "s": return None  # skip
      - elif choice == "t": return "trash"
      - elif choice == "r":
        - query = Prompt.ask("[bold]Recherche[/]")
        - **Utiliser determine_is_series(pending)** pour detecter automatiquement le type
        - is_series = determine_is_series(pending)
        - results = await service.search_manual(query, is_series=is_series)
        - Si results: paginator = CandidatePaginator(results)
        - Sinon: console.print("[yellow]Aucun resultat[/]")
      - elif choice == "i":
        - id_input = Prompt.ask("[bold]ID externe[/]")
        - id_type, id_value = detect_external_id(id_input)
        - Si id_type == "numeric":
          - source = Prompt.ask("Source", choices=["tmdb", "tvdb"], default="tmdb")
          - id_type = source
        - Si id_type:
          - details = await service.search_by_external_id(id_type, id_value)
          - Si details: afficher et demander confirmation
      - elif choice == "n" et paginator.has_more():
        - paginator.next_page()
      - elif choice == "?": display_help()
      - elif choice == "q": return "quit"

11. **Fonction display_batch_summary(transfers: list[dict]):**
    **Implementation complete avec rich.table.Table:**
    ```python
    def display_batch_summary(transfers: list[dict]) -> None:
        """
        Affiche un resume des transferts prevus sous forme de tableau.

        Args:
            transfers: Liste de dicts avec keys 'source', 'destination', 'new_filename', 'action'
        """
        from rich.table import Table

        table = Table(title="Transferts a effectuer", show_header=True, header_style="bold magenta")
        table.add_column("#", style="dim", width=4)
        table.add_column("Fichier source", style="cyan", no_wrap=True)
        table.add_column("Destination", style="green")
        table.add_column("Action", style="yellow")

        for idx, transfer in enumerate(transfers, start=1):
            source_name = transfer["source"].name if hasattr(transfer["source"], "name") else str(transfer["source"])
            dest_str = str(transfer["destination"])
            action = transfer.get("action", "move+symlink")
            table.add_row(str(idx), source_name, dest_str, action)

        console.print(table)
    ```

12. **Fonction async execute_batch_transfer(transfers: list[dict], transferer) -> list[dict]:**
    **Implementation complete avec signature transferer.transfer_file:**
    ```python
    async def execute_batch_transfer(transfers: list[dict], transferer) -> list[dict]:
        """
        Execute les transferts avec barre de progression.

        Signature transferer.transfer_file(source, destination, create_symlink=True) -> TransferResult

        Args:
            transfers: Liste de dicts avec keys 'source', 'destination'
            transferer: TransfererService injecte

        Returns:
            Liste de dicts {'success': bool, 'filename': str, 'error': str | None}
        """
        results = []

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=console,
        ) as progress:
            task = progress.add_task("Transfert...", total=len(transfers))

            for transfer in transfers:
                source = transfer["source"]
                destination = transfer["destination"]
                filename = source.name if hasattr(source, "name") else str(source)

                progress.update(task, description=f"[cyan]{filename}[/]")

                # Appel transferer.transfer_file(source, destination, create_symlink=True)
                # Retourne TransferResult avec .success, .error, .conflict
                result: TransferResult = transferer.transfer_file(
                    source=source,
                    destination=destination,
                    create_symlink=True,
                )

                if result.success:
                    results.append({"success": True, "filename": filename, "error": None})
                else:
                    error_msg = result.error or (str(result.conflict) if result.conflict else "Erreur inconnue")
                    results.append({"success": False, "filename": filename, "error": error_msg})

                progress.advance(task)

        return results
    ```
  </action>
  <verify>
`python -c "from src.adapters.cli.validation import CandidatePaginator, render_candidate_card, validation_loop, determine_is_series; print('OK')"`
  </verify>
  <done>
Module validation.py avec toutes les fonctions d'affichage et boucle interactive implementees, incluant determine_is_series() et implementations completes de display_batch_summary/execute_batch_transfer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Creer les commandes Typer avec batch complet</name>
  <files>src/adapters/cli/commands.py</files>
  <action>
Creer src/adapters/cli/commands.py avec les commandes Typer.

**Note importante sur les signatures des services (verifiees dans le contexte):**

- `RenamerService.generate_movie_filename(movie: Movie, media_info: MediaInfo | None, extension: str) -> str`
- `RenamerService.generate_series_filename(series: Series, episode: Episode, media_info: MediaInfo | None, extension: str) -> str`
- `OrganizerService.get_movie_destination(movie: Movie, storage_dir: Path) -> Path`
- `OrganizerService.get_series_destination(series: Series, season_number: int, storage_dir: Path) -> Path`
- `TransfererService.transfer_file(source: Path, destination: Path, create_symlink: bool = True) -> TransferResult`

1. **Structure de base:**
   ```python
   import asyncio
   from pathlib import Path
   import typer
   from rich.console import Console
   from rich.prompt import Confirm

   from src.container import Container
   from src.core.entities.video import ValidationStatus
   from src.core.entities.media import Movie, Series, Episode
   from src.adapters.cli.validation import (
       validation_loop,
       display_batch_summary,
       execute_batch_transfer,
       determine_is_series,
       console,
   )

   validate_app = typer.Typer(
       name="validate",
       help="Commandes de validation des fichiers",
       rich_markup_mode="rich",
   )
   ```

2. **Commande validate auto:**
   ```python
   @validate_app.command("auto")
   def validate_auto():
       """Valide automatiquement les fichiers avec score >= 85% et candidat unique."""
       asyncio.run(_validate_auto_async())

   async def _validate_auto_async():
       container = Container()
       await container.database.init()

       service = container.validation_service()
       pending_list = service.list_pending()

       auto_count = 0
       for pending in pending_list:
           result = await service.process_auto_validation(pending)
           if result.auto_validated:
               auto_count += 1
               console.print(f"[green]Auto-valide:[/] {result.video_file.filename}")

       console.print(f"\n[bold]{auto_count}[/] fichier(s) valide(s) automatiquement.")
   ```

3. **Commande validate manual:**
   ```python
   @validate_app.command("manual")
   def validate_manual():
       """Lance la validation manuelle interactive pour les fichiers en attente."""
       asyncio.run(_validate_manual_async())

   async def _validate_manual_async():
       container = Container()
       await container.database.init()

       service = container.validation_service()
       pending_list = service.list_pending()

       # Filtrer les non-auto-validates
       pending_list = [p for p in pending_list if not p.auto_validated]

       if not pending_list:
           console.print("[yellow]Aucun fichier en attente de validation manuelle.[/]")
           return

       validated = []
       for pending in pending_list:
           result = await validation_loop(pending, service)

           if result == "quit":
               break
           elif result == "trash":
               service.reject_pending(pending)
               console.print(f"[red]Corbeille:[/] {pending.video_file.filename}")
           elif result is None:
               console.print(f"[yellow]Passe:[/] {pending.video_file.filename}")
           else:
               # result est l'ID du candidat selectionne
               candidate = next((c for c in pending.candidates if c.id == result), None)
               if candidate:
                   details = await service.validate_candidate(pending, candidate)
                   validated.append({"pending": pending, "details": details})
                   console.print(f"[green]Valide:[/] {pending.video_file.filename} -> {details.title}")

       console.print(f"\n[bold]{len(validated)}[/] fichier(s) valide(s).")
   ```

4. **Commande validate batch (IMPLEMENTATION COMPLETE):**
   La logique de construction des transferts reste dans commands.py car elle est specifique au CLI
   et n'a pas besoin d'etre reutilisee par le Web (qui aura sa propre UX).

   ```python
   @validate_app.command("batch")
   def validate_batch():
       """Affiche et execute le batch de transferts pour les fichiers valides."""
       asyncio.run(_validate_batch_async())

   async def _validate_batch_async():
       container = Container()
       config = container.config()
       await container.database.init()

       # Recuperer les services necessaires
       service = container.validation_service()
       renamer = container.renamer_service()
       organizer = container.organizer_service()

       # Recuperer TransfererService avec les paths de config
       transferer = container.transferer_service(
           storage_dir=Path(config.storage_dir),
           video_dir=Path(config.video_dir),
       )

       # Recuperer les fichiers valides (status=VALIDATED)
       validated_list = service.list_validated()

       if not validated_list:
           console.print("[yellow]Aucun fichier valide pret pour transfert.[/]")
           console.print("Utilisez 'validate auto' ou 'validate manual' d'abord.")
           return

       # Construire la liste des transferts
       transfers = []
       storage_dir = Path(config.storage_dir)

       for pending in validated_list:
           # Recuperer le candidat selectionne
           candidate = next(
               (c for c in pending.candidates if c.id == pending.selected_candidate_id),
               None
           )
           if not candidate:
               console.print(f"[red]Erreur:[/] Candidat non trouve pour {pending.video_file.filename}")
               continue

           # Determiner si c'est une serie
           is_series = candidate.source == "tvdb"

           # Extraire l'extension du fichier source
           source_path = pending.video_file.path
           extension = source_path.suffix if source_path else ".mkv"

           # Generer le nouveau nom et chemin de destination
           if is_series:
               # Pour les series: extraire saison/episode de media_info.guessed
               guessed = pending.video_file.media_info.guessed if pending.video_file.media_info else {}
               season_num = guessed.get("season", 1)
               episode_num = guessed.get("episode", 1)
               episode_title = guessed.get("episode_title", "")

               # Construire les entites Series et Episode pour renamer/organizer
               series = Series(
                   title=candidate.title,
                   year=candidate.year,
               )
               episode = Episode(
                   season_number=season_num,
                   episode_number=episode_num,
                   title=episode_title,
               )

               new_filename = renamer.generate_series_filename(
                   series=series,
                   episode=episode,
                   media_info=pending.video_file.media_info,
                   extension=extension,
               )
               dest_dir = organizer.get_series_destination(
                   series=series,
                   season_number=season_num,
                   storage_dir=storage_dir,
               )
           else:
               # Pour les films: construire entite Movie
               movie = Movie(
                   title=candidate.title,
                   year=candidate.year,
                   genres=(),  # Genres seront enrichis si MediaDetails disponibles
               )

               new_filename = renamer.generate_movie_filename(
                   movie=movie,
                   media_info=pending.video_file.media_info,
                   extension=extension,
               )
               dest_dir = organizer.get_movie_destination(
                   movie=movie,
                   storage_dir=storage_dir,
               )

           transfers.append({
               "pending": pending,
               "source": source_path,
               "destination": dest_dir / new_filename,
               "new_filename": new_filename,
               "action": "move+symlink",
           })

       if not transfers:
           console.print("[yellow]Aucun transfert a effectuer.[/]")
           return

       # Afficher le resume du batch
       console.print(f"\n[bold]Batch de transfert: {len(transfers)} fichier(s)[/]\n")
       display_batch_summary(transfers)

       # Demander confirmation
       if not Confirm.ask("\n[bold]Executer le transfert ?[/]", default=False):
           console.print("[yellow]Transfert annule.[/]")
           return

       # Executer le batch
       console.print("\n[bold]Transfert en cours...[/]\n")
       results = await execute_batch_transfer(transfers, transferer)

       # Afficher le bilan
       success_count = sum(1 for r in results if r.get("success", False))
       error_count = len(results) - success_count

       console.print(f"\n[bold green]{success_count}[/] fichier(s) transfere(s)")
       if error_count > 0:
           console.print(f"[bold red]{error_count}[/] erreur(s)")
           for r in results:
               if not r.get("success", False):
                   console.print(f"  [red]- {r.get('filename', '?')}: {r.get('error', 'Erreur inconnue')}[/]")
   ```

5. **Fonction helper pour wrapper async:**
   Note: Typer ne supporte pas async nativement. Utiliser asyncio.run() dans chaque commande.

Important pour Task 2:
- La commande batch DOIT etre completement implementee (pas de TODO/stub)
- Utiliser service.list_validated() pour recuperer les fichiers valides
- Utiliser container.transferer_service(storage_dir=..., video_dir=...) avec les paths de config
- Pour les series: extraire season/episode de media_info.guessed (season, episode, episode_title)
- Construire les entites Movie/Series/Episode requises par renamer et organizer
  </action>
  <verify>
`python -c "from src.adapters.cli.commands import validate_app; print('OK')"`

Verifier que batch n'est pas un stub:
`grep -c "TODO" src/adapters/cli/commands.py` devrait retourner 0
  </verify>
  <done>
Commandes Typer validate auto, manual, batch creees avec implementations completes. Batch construit les entites Movie/Series/Episode avec signatures verifiees de renamer/organizer, et extrait saison/episode de guessed pour les series.
  </done>
</task>

<task type="auto">
  <name>Task 3: Ecrire les tests CLI</name>
  <files>tests/unit/adapters/cli/__init__.py, tests/unit/adapters/cli/test_validation.py</files>
  <action>
Creer tests/unit/adapters/cli/__init__.py (vide) si inexistant.

Creer tests/unit/adapters/cli/test_validation.py avec:

1. **Imports et fixtures:**
   ```python
   import pytest
   from unittest.mock import MagicMock, AsyncMock, patch
   from pathlib import Path

   from src.adapters.cli.validation import (
       CandidatePaginator,
       render_candidate_card,
       detect_external_id,
       display_help,
       display_batch_summary,
       determine_is_series,
   )
   from src.core.ports.api_clients import SearchResult
   from src.core.entities.video import PendingValidation, VideoFile
   from src.core.value_objects.media_info import MediaInfo
   ```

2. **Tests CandidatePaginator:**
   - test_paginator_total_pages: 12 items, page_size=5 -> 3 pages
   - test_paginator_current_items: page 0 -> 5 premiers
   - test_paginator_select: select(2) sur page 0 -> item index 1
   - test_paginator_next_page: incremente current_page
   - test_paginator_has_more: True si plus de pages

3. **Tests render_candidate_card:**
   - test_render_candidate_card_basic: Panel cree avec titre correct
   - test_render_candidate_card_best: is_best=True -> bordure verte
   - test_render_candidate_card_score_color: score >= 85 -> vert, < 85 -> jaune

4. **Tests detect_external_id:**
   - test_detect_imdb_id: "tt1234567" -> ("imdb", "tt1234567")
   - test_detect_numeric_id: "12345" -> ("numeric", "12345")
   - test_detect_unknown: "avatar" -> (None, None)

5. **Tests determine_is_series:**
   - test_determine_is_series_episode_type: guessed["type"]="episode" -> True
   - test_determine_is_series_movie_type: guessed["type"]="movie" -> False
   - test_determine_is_series_no_type: guessed sans "type" -> False
   - test_determine_is_series_no_media_info: media_info=None -> False
   - test_determine_is_series_no_guessed: guessed=None -> False

6. **Tests display_batch_summary:**
   - test_display_batch_summary_creates_table: verifie qu'une Table est creee (patch console.print)
   - test_display_batch_summary_shows_all_transfers: verifie toutes les lignes presentes

7. **Tests integration (avec mocks):**
   - test_validation_loop_select: mock Prompt.ask retourne "1", verifie selection
   - test_validation_loop_skip: mock retourne "s", verifie return None
   - test_validation_loop_quit: mock retourne "q", verifie return "quit"
   - test_validation_loop_search_uses_determine_is_series: verifie que determine_is_series est appele

Note: Pour les tests de boucle interactive, utiliser monkeypatch ou patch sur Prompt.ask
pour simuler les inputs utilisateur.
  </action>
  <verify>
`pytest tests/unit/adapters/cli/test_validation.py -v` passe avec tous les tests verts.
  </verify>
  <done>
Tests unitaires CLI couvrant paginator, affichage, detection ID, determine_is_series, batch summary, et boucle interactive mockee.
  </done>
</task>

</tasks>

<verification>
1. Tous les tests passent: `pytest tests/unit/adapters/cli/ -v`
2. Import des modules: `python -c "from src.adapters.cli.validation import validation_loop, determine_is_series; from src.adapters.cli.commands import validate_app"`
3. Pas de TODO/stub dans batch: `grep -c "TODO\|stub" src/adapters/cli/commands.py` retourne 0
4. Help des commandes: `python -m src.adapters.cli.commands --help` (si point d'entree configure)
5. Pas de regression: `pytest tests/ -v`
</verification>

<success_criteria>
- Interface CLI affiche les candidats en cartes avec badge RECOMMANDE
- Commandes validate auto/manual/batch fonctionnelles
- Commande batch completement implementee (pas de stub)
- Batch utilise list_validated(), construit entites Movie/Series/Episode, appelle renamer/organizer avec signatures verifiees
- determine_is_series() extrait automatiquement le type depuis media_info.guessed["type"]
- Boucle interactive supporte selection, skip, trash, recherche (avec detection is_series automatique), ID externe
- Tests couvrent les scenarios principaux avec mocks incluant determine_is_series
- Aucune regression sur les tests existants
</success_criteria>

<output>
Apres completion, creer `.planning/phases/06-validation/06-02-SUMMARY.md`
</output>
