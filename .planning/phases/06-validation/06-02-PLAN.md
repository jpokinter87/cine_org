---
phase: 06-validation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/adapters/cli/__init__.py
  - src/adapters/cli/validation.py
  - src/adapters/cli/commands.py
  - tests/unit/adapters/cli/test_validation.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "L'utilisateur voit les candidats affiches en cartes detaillees avec badge RECOMMANDE"
    - "L'utilisateur peut selectionner un candidat par numero (1, 2, 3...)"
    - "L'utilisateur peut passer, rechercher manuellement, saisir ID externe, ou mettre en corbeille"
    - "Le batch final affiche tous les fichiers avec destinations et demande confirmation"
    - "Le transfert affiche une barre de progression avec fichier en cours"
  artifacts:
    - path: "src/adapters/cli/validation.py"
      provides: "Interface CLI interactive de validation avec Rich"
      min_lines: 200
    - path: "src/adapters/cli/commands.py"
      provides: "Commandes Typer pour validation (auto, manual, batch)"
      exports: ["validate_app"]
    - path: "tests/unit/adapters/cli/test_validation.py"
      provides: "Tests CLI avec mocks pour les prompts"
      min_lines: 100
  key_links:
    - from: "src/adapters/cli/validation.py"
      to: "src/services/validation.py"
      via: "ValidationService pour la logique metier"
      pattern: "ValidationService|validation_service"
    - from: "src/adapters/cli/validation.py"
      to: "rich.panel"
      via: "Rich Panel pour affichage cartes candidats"
      pattern: "Panel|rich\\.panel"
    - from: "src/adapters/cli/commands.py"
      to: "src/adapters/cli/validation.py"
      via: "Import des fonctions d'affichage et boucle interactive"
      pattern: "validation_loop|display_candidates"
---

<objective>
Creer l'interface CLI interactive de validation avec Rich pour affichage des candidats et barre de progression.

Purpose: Permettre a l'utilisateur de valider manuellement les fichiers ambigus avec une interface agreable.
Output: Module CLI avec commandes validate (auto, manual, batch) utilisant Rich pour l'affichage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-validation/06-RESEARCH.md
@.planning/phases/06-validation/06-CONTEXT.md
@.planning/phases/06-validation/06-01-SUMMARY.md
@src/services/validation.py
@src/services/transferer.py
@src/core/entities/video.py
@src/core/ports/api_clients.py
@src/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer le module d'affichage CLI validation</name>
  <files>src/adapters/cli/__init__.py, src/adapters/cli/validation.py</files>
  <action>
Creer le repertoire src/adapters/cli/ avec __init__.py vide si inexistant.

Creer src/adapters/cli/validation.py avec:

1. **Imports necessaires:**
   ```python
   import asyncio
   import re
   from rich.console import Console
   from rich.panel import Panel
   from rich.table import Table
   from rich.text import Text
   from rich.prompt import Prompt, Confirm
   from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn

   from src.core.entities.video import PendingValidation, ValidationStatus
   from src.core.ports.api_clients import SearchResult, MediaDetails
   from src.services.validation import ValidationService
   ```

2. **Console globale:**
   `console = Console()`

3. **Constantes:**
   ```python
   PAGE_SIZE = 5  # Nombre de candidats par page
   IMDB_PATTERN = re.compile(r"^tt\d{7,8}$", re.IGNORECASE)
   ```

4. **Classe CandidatePaginator:**
   ```python
   class CandidatePaginator:
       def __init__(self, candidates: list[SearchResult], page_size: int = PAGE_SIZE):
           self.candidates = candidates
           self.page_size = page_size
           self.current_page = 0

       @property
       def total_pages(self) -> int:
           return (len(self.candidates) + self.page_size - 1) // self.page_size

       @property
       def current_items(self) -> list[SearchResult]:
           start = self.current_page * self.page_size
           return self.candidates[start:start + self.page_size]

       def select(self, display_number: int) -> SearchResult | None:
           idx = (self.current_page * self.page_size) + display_number - 1
           if 0 <= idx < len(self.candidates):
               return self.candidates[idx]
           return None

       def next_page(self) -> bool:
           if self.current_page + 1 < self.total_pages:
               self.current_page += 1
               return True
           return False

       def has_more(self) -> bool:
           return self.current_page + 1 < self.total_pages
   ```

5. **Fonction render_candidate_card(candidate: SearchResult, rank: int, is_best: bool = False) -> Panel:**
   - Cree un Text avec: titre (bold), annee, score (vert si >= 85, jaune sinon), source
   - Ajoute genres tronques (3 max) si disponibles dans candidate (note: SearchResult n'a pas genres, ils viennent de MediaDetails - afficher seulement titre/annee/score/source)
   - Titre du Panel: "[rank]" avec "[bold green]* RECOMMANDE[/]" si is_best
   - Bordure verte si is_best, blanche sinon
   - Retourne le Panel

6. **Fonction display_candidates(paginator: CandidatePaginator, pending: PendingValidation):**
   - Affiche header avec nom du fichier (pending.video_file.filename)
   - Pour chaque candidat de paginator.current_items:
     - Appelle render_candidate_card(candidate, rank, is_best=(rank==1 et page==0))
     - console.print(panel)
   - Si paginator.has_more(): affiche "[dim]Autres candidats disponibles...[/]"

7. **Fonction display_help():**
   - Affiche les commandes disponibles: [1-5] selectionner, [s] passer, [t] corbeille, [r] rechercher, [i] ID externe, [d] details, [?] aide, [q] quitter

8. **Fonction detect_external_id(user_input: str) -> tuple[str | None, str | None]:**
   - Si IMDB_PATTERN.match(user_input): return ("imdb", user_input.lower())
   - Si user_input.isdigit(): return ("numeric", user_input)  # Caller demande tmdb/tvdb
   - Sinon: return (None, None)

9. **Fonction async validation_loop(pending: PendingValidation, service: ValidationService) -> str | None:**
   - Cree un CandidatePaginator avec pending.candidates
   - Boucle while True:
     - display_candidates(paginator, pending)
     - choice = Prompt.ask("[bold]Choix[/]", default="1")
     - Si choice.isdigit() et 1 <= int(choice) <= len(paginator.current_items):
       - candidate = paginator.select(int(choice))
       - Afficher mini-recap avec destination proposee (titre (annee))
       - Si Confirm.ask("Valider ?"): return candidate.id
     - elif choice == "s": return None  # skip
     - elif choice == "t": return "trash"
     - elif choice == "r":
       - query = Prompt.ask("[bold]Recherche[/]")
       - results = await service.search_manual(query, is_series=False)  # Determiner is_series depuis context
       - Si results: paginator = CandidatePaginator(results)
       - Sinon: console.print("[yellow]Aucun resultat[/]")
     - elif choice == "i":
       - id_input = Prompt.ask("[bold]ID externe[/]")
       - id_type, id_value = detect_external_id(id_input)
       - Si id_type == "numeric":
         - source = Prompt.ask("Source", choices=["tmdb", "tvdb"], default="tmdb")
         - id_type = source
       - Si id_type:
         - details = await service.search_by_external_id(id_type, id_value)
         - Si details: afficher et demander confirmation
     - elif choice == "n" et paginator.has_more():
       - paginator.next_page()
     - elif choice == "?": display_help()
     - elif choice == "q": return "quit"

10. **Fonction display_batch_summary(transfers: list[dict]):**
    - Cree une Table avec colonnes: #, Fichier source, Destination, Action
    - Pour chaque transfer: ajoute une row
    - console.print(table)

11. **Fonction async execute_batch_transfer(transfers: list[dict], transferer) -> list[dict]:**
    - Avec Progress (SpinnerColumn, TextColumn, BarColumn, percentage, count):
      - Pour chaque transfer:
        - Update description avec nom fichier
        - Appeler transferer.transfer_file(...)
        - Advance progress
    - Retourne liste des resultats (succes/erreurs)
  </action>
  <verify>
`python -c "from src.adapters.cli.validation import CandidatePaginator, render_candidate_card, validation_loop; print('OK')"`
  </verify>
  <done>
Module validation.py avec toutes les fonctions d'affichage et boucle interactive implementees.
  </done>
</task>

<task type="auto">
  <name>Task 2: Creer les commandes Typer</name>
  <files>src/adapters/cli/commands.py</files>
  <action>
Creer src/adapters/cli/commands.py avec les commandes Typer:

1. **Structure de base:**
   ```python
   import asyncio
   import typer
   from rich.console import Console

   from src.container import Container
   from src.adapters.cli.validation import (
       validation_loop,
       display_batch_summary,
       execute_batch_transfer,
       console,
   )

   validate_app = typer.Typer(
       name="validate",
       help="Commandes de validation des fichiers",
       rich_markup_mode="rich",
   )
   ```

2. **Commande validate auto:**
   ```python
   @validate_app.command("auto")
   def validate_auto():
       """Valide automatiquement les fichiers avec score >= 85% et candidat unique."""
       asyncio.run(_validate_auto_async())

   async def _validate_auto_async():
       container = Container()
       await container.database.init()

       service = container.validation_service()
       pending_list = service.list_pending()

       auto_count = 0
       for pending in pending_list:
           result = await service.process_auto_validation(pending)
           if result.auto_validated:
               auto_count += 1
               console.print(f"[green]Auto-valide:[/] {result.video_file.filename}")

       console.print(f"\n[bold]{auto_count}[/] fichier(s) valide(s) automatiquement.")
   ```

3. **Commande validate manual:**
   ```python
   @validate_app.command("manual")
   def validate_manual():
       """Lance la validation manuelle interactive pour les fichiers en attente."""
       asyncio.run(_validate_manual_async())

   async def _validate_manual_async():
       container = Container()
       await container.database.init()

       service = container.validation_service()
       pending_list = service.list_pending()

       # Filtrer les non-auto-validates
       pending_list = [p for p in pending_list if not p.auto_validated]

       if not pending_list:
           console.print("[yellow]Aucun fichier en attente de validation manuelle.[/]")
           return

       validated = []
       for pending in pending_list:
           result = await validation_loop(pending, service)

           if result == "quit":
               break
           elif result == "trash":
               service.reject_pending(pending)
               console.print(f"[red]Corbeille:[/] {pending.video_file.filename}")
           elif result is None:
               console.print(f"[yellow]Passe:[/] {pending.video_file.filename}")
           else:
               # result est l'ID du candidat selectionne
               candidate = next((c for c in pending.candidates if c.id == result), None)
               if candidate:
                   details = await service.validate_candidate(pending, candidate)
                   validated.append({"pending": pending, "details": details})
                   console.print(f"[green]Valide:[/] {pending.video_file.filename} -> {details.title}")

       console.print(f"\n[bold]{len(validated)}[/] fichier(s) valide(s).")
   ```

4. **Commande validate batch:**
   ```python
   @validate_app.command("batch")
   def validate_batch():
       """Affiche et execute le batch de transferts pour les fichiers valides."""
       asyncio.run(_validate_batch_async())

   async def _validate_batch_async():
       container = Container()
       await container.database.init()

       # Recuperer les fichiers valides (status=VALIDATED) prets pour transfert
       # Note: Ceci necessite une methode list_validated() ou filtrage
       service = container.validation_service()

       # Pour l'instant, on simule avec les pending valides
       # TODO: Implementer la recuperation des fichiers valides avec leurs details

       console.print("[yellow]Commande batch a completer avec le workflow de transfert.[/]")
       console.print("Utiliser apres validation pour transferer les fichiers.")
   ```

5. **Fonction helper pour wrapper async:**
   Note: Typer ne supporte pas async nativement. Utiliser asyncio.run() dans chaque commande.
  </action>
  <verify>
`python -c "from src.adapters.cli.commands import validate_app; print('OK')"`
  </verify>
  <done>
Commandes Typer validate auto, manual, batch creees avec wrappers async.
  </done>
</task>

<task type="auto">
  <name>Task 3: Ecrire les tests CLI</name>
  <files>tests/unit/adapters/cli/__init__.py, tests/unit/adapters/cli/test_validation.py</files>
  <action>
Creer tests/unit/adapters/cli/__init__.py (vide) si inexistant.

Creer tests/unit/adapters/cli/test_validation.py avec:

1. **Imports et fixtures:**
   ```python
   import pytest
   from unittest.mock import MagicMock, AsyncMock, patch
   from io import StringIO

   from src.adapters.cli.validation import (
       CandidatePaginator,
       render_candidate_card,
       detect_external_id,
       display_help,
   )
   from src.core.ports.api_clients import SearchResult
   ```

2. **Tests CandidatePaginator:**
   - test_paginator_total_pages: 12 items, page_size=5 -> 3 pages
   - test_paginator_current_items: page 0 -> 5 premiers
   - test_paginator_select: select(2) sur page 0 -> item index 1
   - test_paginator_next_page: incremente current_page
   - test_paginator_has_more: True si plus de pages

3. **Tests render_candidate_card:**
   - test_render_candidate_card_basic: Panel cree avec titre correct
   - test_render_candidate_card_best: is_best=True -> bordure verte
   - test_render_candidate_card_score_color: score >= 85 -> vert, < 85 -> jaune

4. **Tests detect_external_id:**
   - test_detect_imdb_id: "tt1234567" -> ("imdb", "tt1234567")
   - test_detect_numeric_id: "12345" -> ("numeric", "12345")
   - test_detect_unknown: "avatar" -> (None, None)

5. **Tests integration (avec mocks):**
   - test_validation_loop_select: mock Prompt.ask retourne "1", verifie selection
   - test_validation_loop_skip: mock retourne "s", verifie return None
   - test_validation_loop_quit: mock retourne "q", verifie return "quit"

Note: Pour les tests de boucle interactive, utiliser monkeypatch ou patch sur Prompt.ask
pour simuler les inputs utilisateur.
  </action>
  <verify>
`pytest tests/unit/adapters/cli/test_validation.py -v` passe avec tous les tests verts.
  </verify>
  <done>
Tests unitaires CLI couvrant paginator, affichage, detection ID, et boucle interactive mockee.
  </done>
</task>

</tasks>

<verification>
1. Tous les tests passent: `pytest tests/unit/adapters/cli/ -v`
2. Import des modules: `python -c "from src.adapters.cli.validation import validation_loop; from src.adapters.cli.commands import validate_app"`
3. Help des commandes: `python -m src.adapters.cli.commands --help` (si point d'entree configure)
4. Pas de regression: `pytest tests/ -v`
</verification>

<success_criteria>
- Interface CLI affiche les candidats en cartes avec badge RECOMMANDE
- Commandes validate auto/manual/batch fonctionnelles
- Boucle interactive supporte selection, skip, trash, recherche, ID externe
- Tests couvrent les scenarios principaux avec mocks
- Aucune regression sur les tests existants
</success_criteria>

<output>
Apres completion, creer `.planning/phases/06-validation/06-02-SUMMARY.md`
</output>
