---
phase: 06-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/validation.py
  - tests/unit/services/test_validation.py
  - src/container.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Les fichiers avec score >= 85% et candidat unique sont marques auto_validated=True"
    - "Les fichiers avec score < 85% ou plusieurs candidats restent en pending"
    - "Le service peut valider un candidat selectionne et mettre a jour le statut"
    - "Le service peut rechercher manuellement par titre ou ID externe"
  artifacts:
    - path: "src/services/validation.py"
      provides: "ValidationService avec logique auto-validation et selection candidat"
      exports: ["ValidationService"]
    - path: "tests/unit/services/test_validation.py"
      provides: "Tests unitaires couvrant tous les scenarios de validation"
      min_lines: 150
  key_links:
    - from: "src/services/validation.py"
      to: "src/services/matcher.py"
      via: "MatcherService.score_results() et MATCH_THRESHOLD"
      pattern: "MatcherService|MATCH_THRESHOLD"
    - from: "src/services/validation.py"
      to: "src/infrastructure/persistence/repositories/pending_validation_repository.py"
      via: "SQLModelPendingValidationRepository pour persistence"
      pattern: "pending.*repository|save|list_pending"
    - from: "src/container.py"
      to: "src/services/validation.py"
      via: "Provider Factory pour injection DI"
      pattern: "ValidationService|validation_service"
---

<objective>
Creer le service de validation orchestrant la logique metier de validation automatique et manuelle.

Purpose: Centraliser les regles de validation (seuil 85%, unicite) dans un service reutilisable par le CLI et futur Web.
Output: ValidationService avec methodes pour auto-validation, selection candidat, recherche manuelle, et gestion statuts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-validation/06-RESEARCH.md
@.planning/phases/06-validation/06-CONTEXT.md
@src/services/matcher.py
@src/core/entities/video.py
@src/core/ports/api_clients.py
@src/infrastructure/persistence/repositories/pending_validation_repository.py
@src/adapters/api/tmdb_client.py
@src/adapters/api/tvdb_client.py
@src/container.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer ValidationService avec logique metier</name>
  <files>src/services/validation.py</files>
  <action>
Creer le service de validation avec:

1. Constante THRESHOLD = 85 (seuil auto-validation)

2. Constructeur avec injection de dependances:
   - pending_repo: SQLModelPendingValidationRepository
   - matcher: MatcherService
   - tmdb_client: TMDBClient (optionnel - peut etre None)
   - tvdb_client: TVDBClient (optionnel - peut etre None)

3. Methode `should_auto_validate(candidates: list[SearchResult]) -> bool`:
   - Retourne True si exactement 1 candidat ET score >= 85
   - Retourne False sinon

4. Methode `async process_auto_validation(pending: PendingValidation) -> PendingValidation`:
   - Appelle should_auto_validate sur pending.candidates
   - Si True: met pending.auto_validated=True, pending.validation_status=VALIDATED, pending.selected_candidate_id=candidat[0].id
   - Sauvegarde via repository et retourne l'entite mise a jour
   - Si False: retourne l'entite inchangee

5. Methode `async validate_candidate(pending: PendingValidation, candidate: SearchResult) -> MediaDetails`:
   - Recupere les details via get_details() du bon client (tmdb ou tvdb selon candidate.source)
   - Met a jour pending.validation_status=VALIDATED, pending.selected_candidate_id=candidate.id
   - Sauvegarde via repository
   - Retourne les MediaDetails

6. Methode `reject_pending(pending: PendingValidation) -> PendingValidation`:
   - Met pending.validation_status=REJECTED
   - Sauvegarde et retourne

7. Methode `async search_manual(query: str, is_series: bool = False, year: int | None = None) -> list[SearchResult]`:
   - Utilise tvdb_client.search si is_series, sinon tmdb_client.search
   - Retourne les resultats (non scores - le scoring sera fait par le CLI si besoin)

8. Methode `async search_by_external_id(id_type: str, id_value: str) -> MediaDetails | None`:
   - Si id_type == "imdb": utiliser tmdb_client.search avec query=id_value (TMDB supporte recherche par IMDB ID via find endpoint - a verifier, sinon utiliser get_details avec find)
   - Si id_type == "tmdb": tmdb_client.get_details(id_value)
   - Si id_type == "tvdb": tvdb_client.get_details(id_value)
   - Retourne MediaDetails ou None si non trouve

9. Methode `list_pending() -> list[PendingValidation]`:
   - Proxy vers pending_repo.list_pending()

Important:
- Utiliser asyncio pour les methodes async
- Gerer le cas ou les clients API sont None (retourner liste vide ou None)
- Les SearchResult venant des candidats existants ont deja un score calcule
  </action>
  <verify>
Le fichier existe avec toutes les methodes. Import sans erreur:
`python -c "from src.services.validation import ValidationService; print('OK')"`
  </verify>
  <done>
ValidationService implemente avec toutes les methodes de validation automatique, manuelle et recherche.
  </done>
</task>

<task type="auto">
  <name>Task 2: Ecrire les tests unitaires TDD-style</name>
  <files>tests/unit/services/test_validation.py</files>
  <action>
Creer des tests exhaustifs pour ValidationService:

1. **Tests should_auto_validate:**
   - test_should_auto_validate_single_high_score: 1 candidat a 90% -> True
   - test_should_auto_validate_single_at_threshold: 1 candidat a 85% -> True
   - test_should_auto_validate_single_below_threshold: 1 candidat a 84% -> False
   - test_should_auto_validate_multiple_high_scores: 2 candidats a 90% -> False
   - test_should_auto_validate_empty_candidates: [] -> False

2. **Tests process_auto_validation:**
   - test_process_auto_validation_success: candidat unique 90% -> auto_validated=True, status=VALIDATED
   - test_process_auto_validation_below_threshold: candidat unique 70% -> inchange
   - test_process_auto_validation_multiple_candidates: 2 candidats -> inchange

3. **Tests validate_candidate:**
   - test_validate_candidate_tmdb: source=tmdb -> appelle tmdb_client.get_details
   - test_validate_candidate_tvdb: source=tvdb -> appelle tvdb_client.get_details
   - test_validate_candidate_updates_status: verifie status=VALIDATED et selected_candidate_id

4. **Tests reject_pending:**
   - test_reject_pending_updates_status: verifie status=REJECTED

5. **Tests search_manual:**
   - test_search_manual_movie: is_series=False -> utilise tmdb_client
   - test_search_manual_series: is_series=True -> utilise tvdb_client
   - test_search_manual_no_client: client None -> retourne []

6. **Tests search_by_external_id:**
   - test_search_by_tmdb_id: id_type=tmdb -> get_details
   - test_search_by_tvdb_id: id_type=tvdb -> get_details
   - test_search_by_unknown_type: id_type=xxx -> None

Utiliser:
- pytest fixtures pour les mocks (MagicMock, AsyncMock)
- Mock des repositories et clients API
- Assertions claires sur les appels de methodes et valeurs retournees
  </action>
  <verify>
`pytest tests/unit/services/test_validation.py -v` passe avec tous les tests verts.
  </verify>
  <done>
Suite de tests complete avec couverture des scenarios auto-validation, validation manuelle, recherche, et rejection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrer ValidationService au container DI</name>
  <files>src/container.py</files>
  <action>
Ajouter le provider pour ValidationService:

1. Importer ValidationService:
   `from .services.validation import ValidationService`

2. Ajouter les providers pour les clients API (s'ils ne sont pas deja presents):
   ```python
   # Clients API - optionnels selon config
   tmdb_client = providers.Singleton(
       TMDBClient,
       api_key=config.provided.tmdb_api_key,
       cache=api_cache,
   )
   tvdb_client = providers.Singleton(
       TVDBClient,
       api_key=config.provided.tvdb_api_key,
       cache=api_cache,
   )
   ```
   Note: Les clients necessitent un APICache. Ajouter le provider si absent:
   ```python
   from .adapters.api.cache import APICache
   api_cache = providers.Singleton(APICache)
   ```

3. Ajouter le provider pour MatcherService (s'il n'existe pas):
   ```python
   from .services.matcher import MatcherService
   matcher_service = providers.Singleton(MatcherService)
   ```

4. Ajouter le provider ValidationService:
   ```python
   validation_service = providers.Factory(
       ValidationService,
       pending_repo=pending_validation_repository,
       matcher=matcher_service,
       tmdb_client=tmdb_client,
       tvdb_client=tvdb_client,
   )
   ```

Note: Verifier que les cles API sont optionnelles dans Settings (tmdb_api_key et tvdb_api_key peuvent etre None). Si absent, passer None aux clients ou utiliser un provider conditionnel.
  </action>
  <verify>
Container charge sans erreur:
`python -c "from src.container import Container; c = Container(); print('OK')"`
  </verify>
  <done>
ValidationService injectable via container.validation_service() avec toutes ses dependances.
  </done>
</task>

</tasks>

<verification>
1. Tous les tests passent: `pytest tests/unit/services/test_validation.py -v`
2. Import du service: `python -c "from src.services.validation import ValidationService"`
3. Import du container: `python -c "from src.container import Container"`
4. Couverture: `pytest tests/unit/services/test_validation.py --cov=src/services/validation --cov-report=term-missing`
</verification>

<success_criteria>
- ValidationService existe avec toutes les methodes documentees
- Tests couvrent les scenarios auto-validation (seuil 85%, unicite)
- Tests couvrent validation manuelle et recherche
- Service integre au container DI
- Aucune regression sur les tests existants
</success_criteria>

<output>
Apres completion, creer `.planning/phases/06-validation/06-01-SUMMARY.md`
</output>
