---
phase: 01-fondations-architecture
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/config.py
  - src/logging_config.py
  - src/container.py
  - src/main.py
  - requirements.txt
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Le container DI peut injecter des implementations concretes pour les ports abstraits"
    - "La configuration via pydantic-settings charge les variables d'environnement et fichier config"
    - "Le logging structure ecrit des logs JSON avec rotation et niveaux configurables"
    - "L'application demarre sans cles API (TMDB/TVDB optionnels)"
  artifacts:
    - path: "src/config.py"
      provides: "Settings class with pydantic-settings"
      contains: "class Settings"
    - path: "src/logging_config.py"
      provides: "configure_logging function with loguru"
      contains: "def configure_logging"
    - path: "src/container.py"
      provides: "DI container with dependency-injector"
      contains: "class Container"
    - path: "src/main.py"
      provides: "CLI entry point with Typer"
      contains: "def main"
    - path: "requirements.txt"
      provides: "Project dependencies"
      contains: "pydantic-settings"
  key_links:
    - from: "src/main.py"
      to: "src/container.py"
      via: "imports and initializes container"
      pattern: "from.*container.*import.*Container"
    - from: "src/main.py"
      to: "src/logging_config.py"
      via: "calls configure_logging at startup"
      pattern: "configure_logging"
    - from: "src/container.py"
      to: "src/config.py"
      via: "provides Settings singleton"
      pattern: "providers\\.Singleton.*Settings"
    - from: "src/container.py"
      to: "src/core/ports"
      via: "references ports for type hints"
      pattern: "from.*core\\.ports.*import"
---

<objective>
Configurer le container DI, le systeme de configuration et le logging structure pour completer les fondations.

Purpose: Permettre l'injection de dependances partagee entre CLI et Web, avec configuration validee et logging structure.
Output: Container DI fonctionnel avec configuration pydantic-settings et logging loguru.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-fondations-architecture/01-RESEARCH.md
@.planning/phases/01-fondations-architecture/01-CONTEXT.md
@.planning/phases/01-fondations-architecture/01-01-SUMMARY.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Creer configuration pydantic-settings et logging loguru</name>
  <files>
    src/config.py
    src/logging_config.py
    requirements.txt
    .env.example
  </files>
  <action>
**1. requirements.txt** - Ajouter les dependances:
```
pydantic-settings>=2.12.0
dependency-injector>=4.48.0
loguru>=0.7.0
typer>=0.15.0
```

**2. src/config.py** - Configuration avec pydantic-settings:

```python
from pathlib import Path
from typing import Optional
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_prefix="CINEORG_",
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

    # Paths (avec expansion ~)
    downloads_dir: Path = Field(default=Path("~/Downloads"))
    storage_dir: Path = Field(default=Path("~/Videos/storage"))
    video_dir: Path = Field(default=Path("~/Videos/video"))

    # Database
    database_url: str = Field(default="sqlite:///cineorg.db")

    # API Keys (OPTIONNELS - features API desactivees si absents)
    tmdb_api_key: Optional[str] = Field(default=None)
    tvdb_api_key: Optional[str] = Field(default=None)

    # Processing
    min_file_size_mb: int = Field(default=100, ge=1)
    max_files_per_subdir: int = Field(default=50, ge=1)
    match_score_threshold: int = Field(default=85, ge=0, le=100)

    # Logging (selon CONTEXT.md: fichier + stderr, rotation 10MB, 5 fichiers)
    log_level: str = Field(default="INFO")
    log_file: Path = Field(default=Path("logs/cineorg.log"))
    log_rotation_size: str = Field(default="10 MB")
    log_retention_count: int = Field(default=5)

    @field_validator("downloads_dir", "storage_dir", "video_dir", "log_file", mode="before")
    @classmethod
    def expand_path(cls, v):
        return Path(v).expanduser()

    @property
    def tmdb_enabled(self) -> bool:
        return self.tmdb_api_key is not None

    @property
    def tvdb_enabled(self) -> bool:
        return self.tvdb_api_key is not None
```

**3. src/logging_config.py** - Logging avec loguru:

```python
import sys
from pathlib import Path
from loguru import logger

def configure_logging(
    log_level: str = "INFO",
    log_file: Path = Path("logs/cineorg.log"),
    rotation_size: str = "10 MB",
    retention_count: int = 5,
) -> None:
    """Configure application logging.

    - Console (stderr): human-readable, colored, for real-time monitoring
    - File: JSON serialized, rotated, for historical analysis
    """
    # Remove default handler
    logger.remove()

    # Console handler - human readable
    logger.add(
        sys.stderr,
        level=log_level,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
               "<level>{level: <8}</level> | "
               "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> | "
               "<level>{message}</level>",
        colorize=True,
    )

    # File handler - JSON for analysis
    log_file.parent.mkdir(parents=True, exist_ok=True)
    logger.add(
        log_file,
        level="DEBUG",  # Capture all (API logs at DEBUG)
        format="{message}",
        serialize=True,  # JSON output
        rotation=rotation_size,
        retention=retention_count,
        compression="zip",
        enqueue=True,  # Thread-safe
    )

    logger.debug("Logging configured", log_file=str(log_file), rotation=rotation_size)
```

**4. .env.example** - Template pour les variables d'environnement:
```
# CineOrg Configuration
# Copy to .env and fill in your values

# Paths (optional, defaults shown)
# CINEORG_DOWNLOADS_DIR=~/Downloads
# CINEORG_STORAGE_DIR=~/Videos/storage
# CINEORG_VIDEO_DIR=~/Videos/video

# Database
# CINEORG_DATABASE_URL=sqlite:///cineorg.db

# API Keys (optional - features disabled if not set)
# CINEORG_TMDB_API_KEY=your_tmdb_key
# CINEORG_TVDB_API_KEY=your_tvdb_key

# Processing
# CINEORG_MIN_FILE_SIZE_MB=100
# CINEORG_MAX_FILES_PER_SUBDIR=50
# CINEORG_MATCH_SCORE_THRESHOLD=85

# Logging
# CINEORG_LOG_LEVEL=INFO
# CINEORG_LOG_FILE=logs/cineorg.log
# CINEORG_LOG_ROTATION_SIZE=10 MB
# CINEORG_LOG_RETENTION_COUNT=5
```
  </action>
  <verify>
    pip install -r requirements.txt && python -c "from src.config import Settings; s = Settings(); print(f'TMDB enabled: {s.tmdb_enabled}')"
  </verify>
  <done>
    Settings charge les env vars avec defaults valides.
    configure_logging cree les handlers stderr et fichier.
    L'app demarre sans cles API (tmdb_enabled=False).
  </done>
</task>

<task type="auto">
  <name>Task 2: Creer le container DI avec dependency-injector</name>
  <files>
    src/container.py
  </files>
  <action>
Creer src/container.py avec dependency-injector.

Le container doit:
1. Fournir Settings comme singleton
2. Preparer les emplacements pour les repositories (stub pour l'instant)
3. Configurer le wiring pour CLI et Web

```python
from dependency_injector import containers, providers
from .config import Settings

class Container(containers.DeclarativeContainer):
    """Application DI container.

    Provides dependency injection for both CLI and Web interfaces.
    Repositories and API clients are added in later phases.
    """

    wiring_config = containers.WiringConfiguration(
        modules=[
            ".main",
            # CLI modules added later
            # ".adapters.cli.commands",
            # Web modules added later
            # ".adapters.web.routes.videos",
        ]
    )

    # Configuration - singleton loaded once
    config = providers.Singleton(Settings)

    # Repositories - to be implemented in Phase 4
    # video_repository = providers.Singleton(...)
    # movie_repository = providers.Singleton(...)

    # API Clients - to be implemented in Phase 3
    # tmdb_client = providers.Factory(...)
    # tvdb_client = providers.Factory(...)

    # Services - to be implemented in later phases
    # scanner = providers.Factory(...)
    # matcher = providers.Factory(...)
```

Le container est minimal pour l'instant - il sera etendu dans les phases suivantes quand les adapters seront implementes.
  </action>
  <verify>
    python -c "from src.container import Container; c = Container(); s = c.config(); print(f'Config loaded: {s.log_level}')"
  </verify>
  <done>
    Container DI cree avec Settings comme provider singleton.
    Le container peut etre instancie et fournir la configuration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Creer le point d'entree CLI avec bootstrap</name>
  <files>
    src/main.py
  </files>
  <action>
Creer src/main.py comme point d'entree CLI avec Typer.

Le bootstrap doit:
1. Initialiser le container DI
2. Configurer le logging depuis les settings
3. Fournir une commande de base pour verifier le fonctionnement

```python
import typer
from loguru import logger
from dependency_injector.wiring import Provide, inject

from .container import Container
from .config import Settings
from .logging_config import configure_logging

app = typer.Typer(
    name="cineorg",
    help="Video library management application",
)
container = Container()


@app.command()
@inject
def info(
    config: Settings = Provide[Container.config],
) -> None:
    """Display current configuration."""
    logger.info("CineOrg configuration")
    typer.echo(f"Downloads: {config.downloads_dir}")
    typer.echo(f"Storage: {config.storage_dir}")
    typer.echo(f"Video: {config.video_dir}")
    typer.echo(f"Database: {config.database_url}")
    typer.echo(f"TMDB API: {'enabled' if config.tmdb_enabled else 'disabled'}")
    typer.echo(f"TVDB API: {'enabled' if config.tvdb_enabled else 'disabled'}")
    typer.echo(f"Log level: {config.log_level}")


@app.command()
def version() -> None:
    """Display version information."""
    typer.echo("CineOrg v0.1.0")


def main() -> None:
    """Application entry point."""
    # Wire DI container
    container.wire(modules=[__name__])

    # Load configuration and setup logging
    settings = container.config()
    configure_logging(
        log_level=settings.log_level,
        log_file=settings.log_file,
        rotation_size=settings.log_rotation_size,
        retention_count=settings.log_retention_count,
    )

    logger.info("CineOrg starting", version="0.1.0")

    # Run CLI
    app()


if __name__ == "__main__":
    main()
```

Verifier que:
- `python -m src.main info` affiche la configuration
- `python -m src.main version` affiche la version
- Les logs sont ecrits en JSON dans logs/cineorg.log
  </action>
  <verify>
    python -m src.main info && python -m src.main version && test -f logs/cineorg.log
  </verify>
  <done>
    CLI demarre avec bootstrap complet (DI + logging).
    Commandes info et version fonctionnent.
    Logs JSON ecrits dans logs/cineorg.log.
  </done>
</task>

</tasks>

<verification>
```bash
# 1. Dependencies installed
pip install -r requirements.txt

# 2. Configuration loads correctly
python -c "
from src.config import Settings
s = Settings()
assert s.log_level == 'INFO', 'Default log level should be INFO'
assert s.tmdb_enabled == False, 'TMDB should be disabled without key'
print('Config OK')
"

# 3. Container provides settings
python -c "
from src.container import Container
c = Container()
s = c.config()
assert s.match_score_threshold == 85
print('Container OK')
"

# 4. CLI runs with DI injection
python -m src.main info
python -m src.main version

# 5. Logging to file works
python -c "
from pathlib import Path
log_file = Path('logs/cineorg.log')
assert log_file.exists(), 'Log file should exist'
content = log_file.read_text()
assert 'CineOrg' in content or '{' in content, 'Should have log content'
print('Logging OK')
"

# 6. Full integration
python -c "
from src.main import main, container
from src.config import Settings
from src.logging_config import configure_logging
from src.container import Container

# All imports work
print('All imports OK')

# Container can be instantiated multiple times (for tests)
c1 = Container()
c2 = Container()
print('Multiple containers OK')
"

echo "All verifications passed"
```
</verification>

<success_criteria>
1. requirements.txt contient pydantic-settings, dependency-injector, loguru, typer
2. Settings charge les variables d'environnement avec prefix CINEORG_
3. Settings a tmdb_enabled et tvdb_enabled properties pour APIs optionnelles
4. configure_logging cree handlers stderr (human) et fichier (JSON rotatif)
5. Container fournit Settings comme singleton
6. main.py initialise container, logging, puis CLI
7. `python -m src.main info` affiche la configuration
8. `python -m src.main version` affiche "CineOrg v0.1.0"
9. logs/cineorg.log contient des logs JSON serialises
</success_criteria>

<output>
After completion, create `.planning/phases/01-fondations-architecture/01-02-SUMMARY.md`
</output>
