---
phase: 04-persistance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/__init__.py
  - src/infrastructure/persistence/__init__.py
  - src/infrastructure/persistence/database.py
  - src/infrastructure/persistence/models.py
  - requirements.txt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "La base SQLite est creee dans data/cineorg.db au premier appel"
    - "Les tables movies, series, episodes, video_files, pending_validations, trash existent"
    - "Les index sur tmdb_id, tvdb_id, imdb_id, title, file_hash accelerent les requetes"
  artifacts:
    - path: "src/infrastructure/persistence/database.py"
      provides: "Engine SQLite, session factory, init_db()"
      exports: ["engine", "get_session", "init_db"]
    - path: "src/infrastructure/persistence/models.py"
      provides: "Modeles SQLModel pour toutes les tables metier"
      exports: ["MovieModel", "SeriesModel", "EpisodeModel", "VideoFileModel", "PendingValidationModel", "TrashModel"]
  key_links:
    - from: "src/infrastructure/persistence/database.py"
      to: "src/infrastructure/persistence/models.py"
      via: "import models dans init_db pour metadata.create_all"
      pattern: "from.*models import"
---

<objective>
Creer l'infrastructure de persistance SQLite avec SQLModel : engine, session factory, et tous les modeles de tables (movies, series, episodes, video_files, pending_validations, trash) avec les index appropries.

Purpose: Fournir la couche de stockage pour la videotheque, separee des entites de domaine selon l'architecture hexagonale
Output: Module infrastructure/persistence/ avec database.py et models.py prets pour les repositories
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-persistance/04-RESEARCH.md
@.planning/phases/04-persistance/04-CONTEXT.md
@src/core/entities/media.py
@src/core/entities/video.py
@src/core/value_objects/media_info.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Infrastructure database SQLite</name>
  <files>
    src/infrastructure/__init__.py
    src/infrastructure/persistence/__init__.py
    src/infrastructure/persistence/database.py
    requirements.txt
  </files>
  <action>
Creer le module infrastructure/persistence avec l'engine SQLite et la session factory.

**src/infrastructure/__init__.py:**
- Docstring documentant le layer infrastructure

**src/infrastructure/persistence/__init__.py:**
- Docstring documentant le module persistance
- Re-export des elements publics (engine, get_session, init_db, tous les modeles)

**src/infrastructure/persistence/database.py:**
- Import SQLModel, Session, create_engine depuis sqlmodel
- Constante DATA_DIR = Path("data") avec mkdir(exist_ok=True, parents=True)
- Constante DATABASE_URL = f"sqlite:///{DATA_DIR}/cineorg.db"
- engine = create_engine(DATABASE_URL, echo=False, connect_args={"check_same_thread": False})
- Fonction get_session() generateur qui yield Session(engine) dans un context manager
- Fonction init_db() qui importe les modeles et appelle SQLModel.metadata.create_all(engine)

**requirements.txt:**
- Ajouter sqlmodel>=0.0.24 aux dependances existantes

IMPORTANT: check_same_thread=False est necessaire pour SQLite avec usage multi-thread/async.
  </action>
  <verify>
```bash
cd /home/jp/PythonProject/cine_org && source .venv/bin/activate && python -c "
from src.infrastructure.persistence.database import engine, get_session, init_db, DATA_DIR
print(f'DATA_DIR: {DATA_DIR}')
print(f'Engine: {engine}')
session = next(get_session())
print(f'Session: {session}')
session.close()
print('Database infrastructure OK')
"
```
  </verify>
  <done>Engine SQLite configure, get_session() retourne une session valide, init_db() pret a creer les tables</done>
</task>

<task type="auto">
  <name>Task 2: Modeles SQLModel avec index</name>
  <files>
    src/infrastructure/persistence/models.py
  </files>
  <action>
Creer tous les modeles SQLModel representant les tables de la base de donnees. Ces modeles sont des adapters DB, distincts des entites de domaine (dataclass dans core/entities/).

**MovieModel (table="movies"):**
- id: int | None = Field(default=None, primary_key=True)
- tmdb_id: int | None = Field(default=None, index=True)
- imdb_id: str | None = Field(default=None, index=True)
- title: str = Field(index=True)
- original_title: str | None = None
- year: int | None = None
- genres_json: str | None = None (JSON serialise, ex: ["Action", "Science-Fiction"])
- duration_seconds: int | None = None
- overview: str | None = None
- poster_path: str | None = None
- file_path: str | None = Field(default=None, index=True) (chemin du fichier associe)
- file_hash: str | None = Field(default=None, index=True)
- codec_video: str | None = None
- codec_audio: str | None = None
- resolution: str | None = None (ex: "1920x1080")
- languages_json: str | None = None (JSON, ex: ["fr", "en"])
- file_size_bytes: int | None = None
- created_at: datetime | None = Field(default_factory=datetime.utcnow)
- updated_at: datetime | None = Field(default_factory=datetime.utcnow)

**SeriesModel (table="series"):**
- id: int | None = Field(default=None, primary_key=True)
- tvdb_id: int | None = Field(default=None, index=True)
- imdb_id: str | None = Field(default=None, index=True)
- title: str = Field(index=True)
- original_title: str | None = None
- year: int | None = None
- genres_json: str | None = None
- overview: str | None = None
- poster_path: str | None = None
- created_at: datetime | None = Field(default_factory=datetime.utcnow)
- updated_at: datetime | None = Field(default_factory=datetime.utcnow)

**EpisodeModel (table="episodes"):**
- id: int | None = Field(default=None, primary_key=True)
- series_id: int = Field(foreign_key="series.id", index=True)
- season_number: int
- episode_number: int
- title: str
- air_date: date | None = None
- duration_seconds: int | None = None
- overview: str | None = None
- file_path: str | None = Field(default=None, index=True)
- file_hash: str | None = Field(default=None, index=True)
- codec_video: str | None = None
- codec_audio: str | None = None
- resolution: str | None = None
- languages_json: str | None = None
- file_size_bytes: int | None = None
- created_at: datetime | None = Field(default_factory=datetime.utcnow)
- updated_at: datetime | None = Field(default_factory=datetime.utcnow)
- Index compose sur (series_id, season_number, episode_number)

**VideoFileModel (table="video_files"):**
- id: int | None = Field(default=None, primary_key=True)
- path: str = Field(index=True) (chemin complet)
- filename: str
- file_hash: str | None = Field(default=None, index=True)
- size_bytes: int = 0
- codec_video: str | None = None
- codec_audio: str | None = None
- resolution_width: int | None = None
- resolution_height: int | None = None
- duration_seconds: int | None = None
- languages_json: str | None = None
- created_at: datetime | None = Field(default_factory=datetime.utcnow)
- updated_at: datetime | None = Field(default_factory=datetime.utcnow)

**PendingValidationModel (table="pending_validations"):**
- id: int | None = Field(default=None, primary_key=True)
- video_file_id: int = Field(foreign_key="video_files.id", index=True)
- candidates_json: str | None = None (JSON serialise, top 5 candidats API)
- auto_validated: bool = False
- validation_status: str = "pending" (pending, validated, rejected)
- selected_candidate_id: str | None = None (tmdb_id ou tvdb_id selectionne)
- created_at: datetime | None = Field(default_factory=datetime.utcnow)
- Property candidates getter/setter pour serialisation JSON transparente

**TrashModel (table="trash"):**
- id: int | None = Field(default=None, primary_key=True)
- entity_type: str (movie, series, episode, video_file)
- original_id: int (ID dans la table source avant suppression)
- metadata_json: str (toutes les metadonnees serialisees pour restauration)
- deleted_at: datetime = Field(default_factory=datetime.utcnow)
- deletion_reason: str | None = None

Utiliser __tablename__ = "nom_table" pour chaque modele.
Utiliser from __future__ import annotations en haut du fichier.
Ajouter les imports necessaires: json, datetime, date, Path, SQLModel, Field.
  </action>
  <verify>
```bash
cd /home/jp/PythonProject/cine_org && source .venv/bin/activate && python -c "
from src.infrastructure.persistence.database import init_db, engine
from src.infrastructure.persistence.models import (
    MovieModel, SeriesModel, EpisodeModel,
    VideoFileModel, PendingValidationModel, TrashModel
)
import os

# Supprimer la DB existante pour test propre
db_path = 'data/cineorg.db'
if os.path.exists(db_path):
    os.remove(db_path)

# Creer les tables
init_db()

# Verifier que les tables existent
from sqlmodel import Session, select, text
with Session(engine) as session:
    # Lister les tables
    result = session.exec(text(\"SELECT name FROM sqlite_master WHERE type='table'\"))
    tables = [row[0] for row in result]
    print(f'Tables creees: {sorted(tables)}')

    # Verifier les index sur movies
    result = session.exec(text(\"SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='movies'\"))
    indexes = [row[0] for row in result]
    print(f'Index sur movies: {indexes}')

# Verifier que tous les modeles sont importables
print('Tous les modeles SQLModel OK')
"
```
  </verify>
  <done>6 tables creees (movies, series, episodes, video_files, pending_validations, trash) avec les index sur tmdb_id, tvdb_id, imdb_id, title, file_hash, path</done>
</task>

</tasks>

<verification>
```bash
# Verification complete de l'infrastructure DB
cd /home/jp/PythonProject/cine_org && source .venv/bin/activate && python -c "
from src.infrastructure.persistence.database import init_db, get_session, engine
from src.infrastructure.persistence.models import (
    MovieModel, SeriesModel, EpisodeModel,
    VideoFileModel, PendingValidationModel, TrashModel
)
from sqlmodel import text
import os

# Reset pour test propre
db_path = 'data/cineorg.db'
if os.path.exists(db_path):
    os.remove(db_path)

init_db()

session = next(get_session())

# Test insertion movie
movie = MovieModel(title='Test Movie', year=2024, tmdb_id=12345)
session.add(movie)
session.commit()
session.refresh(movie)
print(f'Movie insere: id={movie.id}, title={movie.title}')

# Test insertion pending_validation
vf = VideoFileModel(path='/test/file.mkv', filename='file.mkv')
session.add(vf)
session.commit()
session.refresh(vf)

pv = PendingValidationModel(video_file_id=vf.id)
session.add(pv)
session.commit()
print(f'PendingValidation cree: id={pv.id}, video_file_id={pv.video_file_id}')

# Verifier les tables
result = session.exec(text(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\"))
tables = [row[0] for row in result]
assert 'movies' in tables
assert 'series' in tables
assert 'episodes' in tables
assert 'video_files' in tables
assert 'pending_validations' in tables
assert 'trash' in tables
print(f'Toutes les tables presentes: {tables}')

session.close()
print('\\n=== Infrastructure DB validee ===' )
"
```
</verification>

<success_criteria>
- [ ] Module src/infrastructure/persistence/ cree avec __init__.py, database.py, models.py
- [ ] Engine SQLite configure avec check_same_thread=False
- [ ] get_session() retourne une session utilisable
- [ ] init_db() cree les 6 tables : movies, series, episodes, video_files, pending_validations, trash
- [ ] Index crees sur : tmdb_id, tvdb_id, imdb_id, title, file_hash, path, series_id
- [ ] requirements.txt contient sqlmodel>=0.0.24
- [ ] Les modeles sont distincts des entites de domaine (architecture hexagonale respectee)
</success_criteria>

<output>
Apres completion, creer `.planning/phases/04-persistance/04-01-SUMMARY.md`
</output>
