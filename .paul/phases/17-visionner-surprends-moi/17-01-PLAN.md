---
phase: 17-visionner-surprends-moi
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/web/routes/library/player.py
  - src/web/routes/library/suggest.py
  - src/web/templates/library/suggest.html
  - src/web/static/css/style.css
  - tests/unit/test_player.py
autonomous: false
---

<objective>
## Goal
Ajouter le bouton Visionner sur les fiches de suggestion de la page Surprends-moi, permettant de lancer la lecture directement sans quitter la page.

## Purpose
L'utilisateur peut actuellement voir une suggestion et doit naviguer vers la fiche détail pour lancer la lecture. Ce plan élimine ce détour en intégrant le bouton play directement dans la carte suggestion.

## Output
- Bouton Visionner fonctionnel sur les suggestions films et séries
- Route play pour séries (premier épisode disponible)
- Polling statut de lecture identique aux fiches détail
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md

## Source Files
@src/web/routes/library/player.py — routes play existantes (movies, episodes) + helpers HTML
@src/web/routes/library/suggest.py — route suggest + _build_item()
@src/web/templates/library/suggest.html — template page Surprends-moi
@src/web/templates/library/movie_detail.html — référence pour intégration bouton play
@src/web/templates/library/series_detail.html — référence pour play épisodes
</context>

<skills>
## Required Skills (from SPECIAL-FLOWS.md)

| Skill | Priority | When to Invoke | Loaded? |
|-------|----------|----------------|---------|
| /frontend-design | required | Intégration bouton play dans suggest.html | ○ |

**BLOCKING:** /frontend-design doit être chargé avant APPLY.

## Skill Invocation Checklist
- [ ] /frontend-design loaded
</skills>

<acceptance_criteria>

## AC-1: Bouton Visionner films
```gherkin
Given une suggestion de film affichée sur la page Surprends-moi
When l'utilisateur clique sur le bouton Visionner
Then le lecteur se lance avec le fichier du film
And le bouton affiche "Lecture en cours…" avec polling statut
And quand la lecture se termine, le bouton Visionner réapparaît
```

## AC-2: Bouton Visionner séries
```gherkin
Given une suggestion de série affichée sur la page Surprends-moi
When l'utilisateur clique sur le bouton Visionner
Then le lecteur se lance avec le premier épisode disponible (S01E01 en priorité)
And le comportement de polling est identique aux films
```

## AC-3: Fichier introuvable
```gherkin
Given une suggestion dont le fichier vidéo est introuvable
When l'utilisateur clique sur le bouton Visionner
Then un message d'erreur "Fichier vidéo introuvable" s'affiche temporairement
And le bouton Visionner réapparaît après quelques secondes
```

## AC-4: Tests
```gherkin
Given les tests existants de player.py
When on exécute la suite de tests
Then les tests existants passent toujours
And la nouvelle route series play est testée
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Route play pour séries + test</name>
  <files>src/web/routes/library/player.py, tests/unit/test_player.py</files>
  <action>
    Ajouter une route `POST /library/series/{series_id}/play` dans player.py :
    - Charger le SeriesModel par ID
    - Chercher le premier épisode avec file_path non null (trié par season_number ASC, episode_number ASC → S01E01 en priorité)
    - Si trouvé, lancer le lecteur via _launch_player() et retourner _playing_html()
    - Si aucun épisode avec fichier, retourner le message "Fichier vidéo introuvable" (même pattern que movie_play)

    Import nécessaire : ajouter SeriesModel aux imports existants.
    Requête : `select(EpisodeModel).where(EpisodeModel.series_id == series_id, EpisodeModel.file_path.is_not(None)).order_by(EpisodeModel.season_number, EpisodeModel.episode_number).first()`

    Ajouter un test dans test_player.py pour la route series_play (mock get_session, mock _launch_player).
  </action>
  <verify>uv run pytest tests/unit/test_player.py -v</verify>
  <done>AC-2, AC-3, AC-4 satisfaits</done>
</task>

<task type="auto">
  <name>Task 2: Bouton Visionner dans le template suggest.html + CSS</name>
  <files>src/web/templates/library/suggest.html, src/web/static/css/style.css</files>
  <action>
    Dans suggest.html, ajouter un bouton Visionner dans la zone `.suggest-actions`, AVANT le bouton "Autre suggestion" :
    - Pour les films : `hx-post="/library/movies/{{ result.id }}/play"` hx-swap="outerHTML"
    - Pour les séries : `hx-post="/library/series/{{ result.id }}/play"` hx-swap="outerHTML"
    - Utiliser le même markup que movie_detail.html (class "play-btn", SVG polygon play)
    - Le bouton doit être conditionnel : `{% if result.type == 'movie' %}...{% else %}...{% endif %}`
    - Ou plus simple : déterminer le endpoint dynamiquement avec `{{ 'movies' if result.type == 'movie' else 'series' }}`

    CSS : les styles `.play-btn`, `.play-launched`, `.play-error` existent déjà dans style.css (utilisés par movie_detail).
    Vérifier qu'ils s'appliquent correctement dans le contexte `.suggest-actions`.
    Ajuster si nécessaire (padding, alignement avec les autres boutons suggest-actions).
  </action>
  <verify>Vérification visuelle dans le navigateur</verify>
  <done>AC-1, AC-2, AC-3 satisfaits visuellement</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Bouton Visionner intégré dans la page Surprends-moi pour films et séries</what-built>
  <how-to-verify>
    1. Ouvrir http://192.168.1.15:8111/library/suggest
    2. Naviguer jusqu'à obtenir un film en suggestion
    3. Cliquer sur Visionner — le lecteur doit se lancer, "Lecture en cours…" affiché
    4. Quand la lecture se termine, le bouton Visionner réapparaît
    5. Naviguer jusqu'à obtenir une série en suggestion
    6. Cliquer sur Visionner — le premier épisode disponible doit se lancer
    7. Vérifier l'alignement visuel du bouton avec les boutons existants
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/web/routes/library/suggest.py — logique de suggestion (filtres, historique, tirage aléatoire)
- src/web/routes/library/helpers.py — fonctions helper partagées
- Routes existantes movies/play et episodes/play dans player.py
- Tests existants dans test_player.py (ne pas modifier, seulement ajouter)

## SCOPE LIMITS
- Pas de modification de _build_item() — le bouton utilise result.id et result.type déjà disponibles
- Pas de streaming vidéo — lancement local/SSH uniquement (comme existant)
- Pas de sélection d'épisode pour les séries — on lance le premier disponible

</boundaries>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/unit/test_player.py -v` — tous les tests passent
- [ ] `uv run pytest tests/ -x -q` — suite complète passe
- [ ] `uv run ruff check src/web/routes/library/player.py src/web/templates/library/suggest.html`
- [ ] Vérification visuelle approuvée (checkpoint)
</verification>

<success_criteria>
- Bouton Visionner visible et fonctionnel sur les suggestions films
- Bouton Visionner visible et fonctionnel sur les suggestions séries (premier épisode)
- Polling statut de lecture opérationnel
- Tous les tests passent (existants + nouveaux)
- Pas de régression visuelle sur la page Surprends-moi
</success_criteria>

<output>
After completion, create `.paul/phases/17-visionner-surprends-moi/17-01-SUMMARY.md`
</output>
