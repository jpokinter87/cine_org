---
phase: 10-detection-automatique-erreurs
plan: 01
type: execute
wave: 1
depends_on: ["09-01"]
files_modified:
  - src/services/association_checker.py
  - src/web/routes/quality.py
  - src/web/templates/quality/suspicious.html
  - src/web/templates/quality/_suspicious_list.html
  - src/web/templates/base.html
  - src/web/app.py
  - src/web/static/css/style.css
  - tests/unit/test_association_checker.py
autonomous: false
---

<objective>
## Goal
Créer un service de détection automatique d'associations TMDB potentiellement erronées et une page web affichant les résultats avec liens vers la correction manuelle (Phase 9).

## Purpose
Permettre à l'utilisateur d'identifier rapidement les films et séries dont l'association TMDB est probablement incorrecte, sans devoir parcourir manuellement chaque fiche.

## Output
- Service `AssociationChecker` avec heuristiques de détection
- Page web `/quality/suspicious` listant les associations suspectes
- Lien vers la correction Phase 9 depuis chaque résultat suspect
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md
@.paul/STATE.md

## Prior Work
@.paul/phases/09-correction-manuelle-associations/09-01-SUMMARY.md
- Phase 9 fournit le mécanisme de correction manuelle (overlay HTMX)
- Helpers `_duration_indicator`, `_series_indicator`, `_get_file_duration`, `_get_local_series_counts` dans library.py

## Source Files
@src/infrastructure/persistence/models.py — MovieModel (file_path, title, year, duration_seconds, tmdb_id), SeriesModel, EpisodeModel
@src/services/matcher.py — _calculate_title_score (rapidfuzz), _calculate_year_score, _calculate_duration_score
@src/adapters/parsing/guessit_parser.py — GuessitFilenameParser.parse() pour extraire titre/année du filename
@src/web/routes/library.py — Helpers _get_file_duration, _duration_indicator, _series_indicator, _get_local_series_counts
@src/web/app.py — Montage des routers
@src/web/templates/base.html — Navigation principale
</context>

<skills>
## Required Skills (from SPECIAL-FLOWS.md)

| Skill | Priority | When to Invoke | Loaded? |
|-------|----------|----------------|---------|
| /frontend-design | required | Avant création template quality/suspicious.html | ○ |

**BLOCKING:** /frontend-design doit être chargé avant APPLY.

## Skill Invocation Checklist
- [ ] /frontend-design loaded
</skills>

<acceptance_criteria>

## AC-1: Détection films suspects par heuristiques
```gherkin
Given une base avec des films ayant tmdb_id et file_path
When le service AssociationChecker scanne les films
Then il identifie comme suspects les films ayant :
  - un écart de durée fichier vs TMDB >= 15 minutes, OU
  - un titre parsé (guessit sur file_path) avec similarité < 60% vs titre TMDB, OU
  - un écart d'année parsée vs TMDB >= 3 ans
Et chaque résultat inclut un score de confiance (0-100) et les raisons
```

## AC-2: Détection séries suspectes par heuristiques
```gherkin
Given une base avec des séries ayant tmdb_id et des épisodes en DB
When le service AssociationChecker scanne les séries
Then il identifie comme suspectes les séries ayant :
  - un titre parsé (guessit sur episode file_path) avec similarité < 60% vs titre TMDB
Et chaque résultat inclut un score de confiance et les raisons
```

## AC-3: Page web listant les associations suspectes
```gherkin
Given le scan a identifié N associations suspectes
When l'utilisateur visite /quality/suspicious
Then il voit la liste des films/séries suspects triés par confiance croissante (les plus suspects en premier)
Et chaque entrée affiche : poster, titre TMDB, titre parsé du fichier, score, raisons
Et un bouton "Corriger" redirige vers la fiche détaillée (qui a le bouton correction Phase 9)
```

## AC-4: Navigation intégrée
```gherkin
Given l'application web est lancée
When l'utilisateur navigue
Then un lien "Qualité" apparaît dans la navigation principale
Et la page /quality/suspicious est accessible
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Service AssociationChecker avec heuristiques de détection</name>
  <files>src/services/association_checker.py, tests/unit/test_association_checker.py</files>
  <action>
    Créer `src/services/association_checker.py` avec une classe `AssociationChecker` :

    **Méthode principale `scan_suspicious() -> list[SuspiciousAssociation]` :**
    - Scanne tous les MovieModel ayant tmdb_id non-null
    - Scanne tous les SeriesModel ayant tmdb_id non-null
    - Pour chaque entité, applique les heuristiques et calcule un score de confiance

    **Dataclass `SuspiciousAssociation` :**
    - entity_type: "movie" | "series"
    - entity_id: int (ID en DB)
    - title_tmdb: str (titre TMDB en DB)
    - title_parsed: str | None (titre extrait du filename via guessit)
    - year_tmdb: int | None
    - year_parsed: int | None
    - confidence_score: int (0=très suspect, 100=probablement correct)
    - reasons: list[str] (raisons humaines)
    - poster_path: str | None

    **Heuristiques Films :**
    1. Durée : si file_path existe, extraire la durée via MediaInfoExtractor et comparer avec duration_seconds (TMDB). Écart >= 15min → pénalité 40 points. Écart 5-15min → pénalité 15 points.
    2. Titre : parser le basename de file_path avec GuessitFilenameParser, comparer le titre parsé avec le titre TMDB via `_calculate_title_score` de matcher.py. Similarité < 60% → pénalité 35 points. 60-75% → pénalité 15 points.
    3. Année : comparer year parsée vs year en DB. Écart >= 3 → pénalité 25 points. Écart 2 → pénalité 10 points.
    - Score initial = 100, on soustrait les pénalités. Score < 60 = suspect.

    **Heuristiques Séries :**
    1. Titre : prendre le file_path du premier épisode, parser avec guessit, comparer avec titre TMDB. Même pénalités que films.
    - Pas de durée unitaire fiable pour les séries.

    **Important :**
    - Réutiliser `_calculate_title_score` de `src/services/matcher.py`
    - Réutiliser `GuessitFilenameParser` pour parser les filenames
    - Pour la durée, utiliser `MediaInfoExtractor` directement (résolution symlink si besoin)
    - Ignorer les entités sans file_path (pas d'heuristique possible)
    - Ne PAS appeler d'API externe — tout est local (DB + fichier)

    **Tests TDD (test_association_checker.py) :**
    - Test heuristique durée : film avec écart > 15min → suspect
    - Test heuristique titre : film avec titre très différent → suspect
    - Test heuristique année : film avec écart >= 3 ans → suspect
    - Test film correct : bon titre + bonne année → non suspect
    - Test série suspecte : titre très différent → suspect
    - Mocker MediaInfoExtractor et la session DB (pas d'I/O réel)
  </action>
  <verify>uv run pytest tests/unit/test_association_checker.py -v</verify>
  <done>AC-1 et AC-2 satisfaits : le service détecte les associations suspectes avec scores et raisons</done>
</task>

<task type="auto">
  <name>Task 2: Page web /quality/suspicious avec routes et templates</name>
  <files>src/web/routes/quality.py, src/web/templates/quality/suspicious.html, src/web/templates/quality/_suspicious_list.html, src/web/templates/base.html, src/web/app.py, src/web/static/css/style.css</files>
  <action>
    **1. Créer `src/web/routes/quality.py` :**
    - Router avec prefix="/quality"
    - Route GET `/suspicious` : instancie AssociationChecker, appelle scan_suspicious(), trie par confidence_score croissant, passe les résultats au template
    - Le scan peut être lent (mediainfo sur chaque film) → prévoir un indicateur de chargement ou un mécanisme SSE. Option simple recommandée : scan synchrone avec message "Analyse en cours..." via hx-indicator

    **2. Créer `src/web/templates/quality/suspicious.html` :**
    - Extends base.html, block title "Qualité — Associations suspectes"
    - En-tête avec titre, nombre total d'éléments suspects, filtres (films/séries/tous)
    - Container pour la liste chargée via HTMX (hx-get="/quality/suspicious/list?filter=all" hx-trigger="load")
    - Spinner pendant le chargement

    **3. Créer `src/web/templates/quality/_suspicious_list.html` :**
    - Fragment HTMX pour la liste des résultats
    - Chaque carte affiche : poster (miniature), titre TMDB, titre parsé du fichier (si différent), score de confiance avec badge coloré (vert > 80, jaune 60-80, rouge < 60), raisons listées
    - Bouton "Voir la fiche" qui redirige vers /library/movies/{id} ou /library/series/{id}
    - Le bouton "Corriger l'association" est sur la fiche (Phase 9), pas ici

    **4. Modifier `src/web/templates/base.html` :**
    - Ajouter un lien "Qualité" dans la nav (entre Bibliothèque et Maintenance)
    - Avec block nav_quality pour la classe active

    **5. Modifier `src/web/app.py` :**
    - Importer et monter le quality_router

    **6. Ajouter les styles dans `src/web/static/css/style.css` :**
    - Styles pour les cartes suspectes (grille, badges confiance, raisons)
    - Cohérent avec le thème sombre existant (Instrument Serif + DM Sans)

    **Pattern existant à suivre :** voir library/index.html et maintenance/index.html pour le layout et le chargement HTMX.
  </action>
  <verify>uv run uvicorn src.web.app:app --host 0.0.0.0 --port 8000 &amp; sleep 2 &amp;&amp; curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/quality/suspicious &amp;&amp; kill %1</verify>
  <done>AC-3 et AC-4 satisfaits : page web accessible, navigation intégrée, liste des associations suspectes affichée</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Service de détection automatique d'associations suspectes + page web /quality/suspicious avec cartes, scores et liens vers les fiches</what-built>
  <how-to-verify>
    1. Lancer le serveur : uv run uvicorn src.web.app:app --reload
    2. Visiter : http://localhost:8000/quality/suspicious
    3. Vérifier : le lien "Qualité" apparaît dans la navigation
    4. Vérifier : la page affiche les associations suspectes avec posters, scores colorés et raisons
    5. Vérifier : le filtre films/séries/tous fonctionne
    6. Cliquer "Voir la fiche" sur un élément → redirige vers la fiche détaillée
    7. Sur la fiche, le bouton "Corriger" de la Phase 9 fonctionne toujours
  </how-to-verify>
  <resume-signal>Type "approved" ou décris les problèmes à corriger</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/services/matcher.py (réutiliser les fonctions existantes, ne pas les modifier)
- src/adapters/parsing/guessit_parser.py (réutiliser tel quel)
- src/web/routes/library.py (ne pas modifier les routes existantes — le code de Phase 9 reste intact)
- src/web/templates/library/* (les templates Phase 9 ne sont pas touchés)

## SCOPE LIMITS
- Pas d'appels API externes (TMDB/TVDB) — tout est local (DB + mediainfo)
- Pas de cache persistant du scan — le scan est à la demande
- Pas de confirmation/dismissal des résultats suspects (c'est Phase 11 — Tableau de Bord)
- Ne pas ajouter de nouvelles dépendances Python

</boundaries>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/unit/test_association_checker.py -v` — tous les tests passent
- [ ] `uv run pytest --tb=short` — aucune régression
- [ ] `uv run ruff check src/services/association_checker.py src/web/routes/quality.py`
- [ ] `uv run ruff format src/services/association_checker.py src/web/routes/quality.py`
- [ ] La page /quality/suspicious est accessible et affiche les résultats
- [ ] La navigation inclut le lien "Qualité"
- [ ] All acceptance criteria met
</verification>

<success_criteria>
- Tous les tests passent (unitaires + régression)
- Le service détecte les films/séries suspects avec scores et raisons
- La page web est fonctionnelle et intégrée à la navigation
- Aucune erreur de lint
- Le mécanisme de correction Phase 9 reste fonctionnel
</success_criteria>

<output>
After completion, create `.paul/phases/10-detection-automatique-erreurs/10-01-SUMMARY.md`
</output>
