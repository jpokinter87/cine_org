---
phase: 03-orchestration-workflow
plan: 01
type: execute
wave: 1
depends_on: ["02-02"]
files_modified:
  - src/web/routes/workflow.py
  - src/web/templates/workflow/index.html
  - src/web/templates/workflow/_progress.html
  - src/web/templates/workflow/_results.html
  - src/web/app.py
  - src/web/static/css/style.css
autonomous: false
---

<objective>
## Goal
Permettre de lancer le workflow complet (scan, matching, auto-validation) depuis l'interface web avec suivi de progression en temps réel et affichage des résultats.

## Purpose
L'utilisateur peut actuellement lancer le workflow uniquement via CLI. L'interface web doit offrir la même fonctionnalité avec un suivi visuel de la progression, sans les points de blocage interactifs du CLI (Rich Confirm.ask, validation_loop). La validation manuelle est déjà couverte par la Phase 2 (pages /validation).

## Output
- Page workflow (/workflow) avec bouton de lancement
- Route POST /workflow/start qui lance scan → matching → auto-validation en arrière-plan
- Endpoint SSE /workflow/progress pour suivi temps réel
- Affichage résultats avec lien vers /validation pour les fichiers restants
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md
@.paul/STATE.md

## Prior Work
@.paul/phases/02-validation-visuelle/02-02-SUMMARY.md
Provides: Routes validation complètes, pattern HTMX établi, _fetch_details helper

## Source Files
@src/services/workflow/workflow_service.py — 8 étapes, 3 points bloquants CLI (Confirm.ask, validation_loop)
@src/services/workflow/dataclasses.py — WorkflowConfig, WorkflowState, WorkflowResult
@src/services/workflow/scan_step.py — _scan_downloads (Rich Progress + Confirm.ask undersized)
@src/services/workflow/matching_step.py — _perform_matching, _auto_validate (Rich Progress)
@src/web/app.py — Lifespan DI, montage routes
@src/web/routes/validation.py — Routes existantes Phase 2
</context>

<skills>
## Required Skills

| Skill | Priority | When to Invoke | Loaded? |
|-------|----------|----------------|---------|
| /frontend-design | required | Before creating templates HTML/CSS | ○ |

**BLOCKING:** Required skills MUST be loaded before APPLY proceeds.

## Skill Invocation Checklist
- [ ] /frontend-design loaded
</skills>

<acceptance_criteria>

## AC-1: Page workflow avec lancement
```gherkin
Given l'utilisateur est sur la page /workflow
When il clique sur le bouton "Lancer le traitement"
Then le workflow démarre (scan → matching → auto-validation)
And le bouton est désactivé pendant le traitement
```

## AC-2: Suivi de progression SSE
```gherkin
Given un workflow est en cours d'exécution
When le serveur émet des événements SSE
Then la page affiche la progression en temps réel (étape courante, compteurs, fichier en cours)
And une barre de progression visuelle est mise à jour
```

## AC-3: Affichage des résultats
```gherkin
Given le workflow est terminé (scan + matching + auto-validation)
When les résultats sont affichés
Then l'utilisateur voit : nombre de fichiers scannés, auto-validés, restants en validation manuelle
And un lien vers /validation est proposé si des fichiers sont en attente
```

## AC-4: Gestion des fichiers sous-dimensionnés
```gherkin
Given le scan détecte des fichiers sous le seuil de taille
When le workflow web s'exécute
Then les fichiers sous-dimensionnés sont automatiquement ignorés (pas de Confirm.ask)
And un message informe l'utilisateur du nombre de fichiers ignorés
```

## AC-5: Gestion des erreurs
```gherkin
Given une erreur survient pendant le workflow (API timeout, etc.)
When l'erreur est détectée
Then un message d'erreur est affiché à l'utilisateur
And le workflow s'arrête proprement sans données corrompues
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Routes workflow + backend SSE + templates</name>
  <files>
    src/web/routes/workflow.py,
    src/web/templates/workflow/index.html,
    src/web/templates/workflow/_progress.html,
    src/web/templates/workflow/_results.html,
    src/web/app.py,
    src/web/static/css/style.css
  </files>
  <action>
    **1. Créer src/web/routes/workflow.py avec 3 routes :**

    **GET /workflow** — Page principale
    - Vérifie s'il y a déjà des pending (workflow en cours ?)
    - Affiche le formulaire de lancement avec options (filtre: all/movies/series)
    - Affiche les résultats du dernier run s'il y en a (pending + validated counts)

    **POST /workflow/start** — Lance le workflow
    - Stocke l'état du workflow dans `app.state.workflow_task` (asyncio.Task)
    - Stocke un objet de progression partagé dans `app.state.workflow_progress` (dict thread-safe)
    - Crée un WorkflowConfig depuis les paramètres du formulaire
    - Lance l'exécution en arrière-plan via asyncio.create_task
    - L'exécution web réutilise les services existants MAIS :
      - PAS de Rich Console/Progress (remplacé par mise à jour du dict de progression)
      - PAS de Confirm.ask pour undersized → les ignorer automatiquement
      - PAS de validation manuelle interactive → s'arrête après auto-validation
      - PAS de batch_transfer → Phase 4
    - Retourne un fragment HTMX qui active le suivi SSE

    **GET /workflow/progress** — SSE (Server-Sent Events)
    - Retourne un StreamingResponse avec content-type text/event-stream
    - Lit `app.state.workflow_progress` et envoie des events :
      - `event: progress` avec data JSON {step, current, total, filename, message}
      - `event: complete` avec data JSON {scanned, auto_validated, pending_remaining}
      - `event: error` avec data JSON {message}
    - Boucle avec asyncio.sleep(0.5) jusqu'à complétion

    **Implémentation du workflow web :**
    Créer une fonction async `run_web_workflow(container, config, progress_dict)` dans workflow.py qui :
    1. Nettoyage orphelins (via validation_service)
    2. Scan downloads (via scanner_service, sans Rich Progress)
    3. Ignore automatiquement les undersized (pas de Confirm)
    4. Matching API (via les mêmes services que WorkflowService)
    5. Auto-validation (via validation_service.process_auto_validation)
    6. Met à jour progress_dict à chaque étape/fichier
    7. S'arrête après auto-validation (la validation manuelle se fait via /validation existant)

    NE PAS réutiliser WorkflowService.execute() directement car il contient des appels Rich/Confirm bloquants.
    Réutiliser les services individuels (scanner, validation_service, matcher, tmdb/tvdb_client).

    **2. Créer les templates :**

    **workflow/index.html** (extends base.html)
    - Formulaire de lancement (bouton + select filtre type)
    - Zone de progression (cachée par défaut, affichée pendant le workflow)
    - Zone de résultats

    **workflow/_progress.html** (fragment HTMX/SSE)
    - Barre de progression avec étape courante
    - Compteurs live (scannés, matchés, auto-validés)
    - Nom du fichier en cours

    **workflow/_results.html** (fragment)
    - Résumé : fichiers scannés, auto-validés, restants
    - Lien vers /validation si pending > 0
    - Message de succès si tout est auto-validé

    **3. Monter le router dans app.py :**
    - Import workflow_router
    - app.include_router(workflow_router)

    **4. Ajouter les styles CSS** pour :
    - Page workflow (bouton lancement, formulaire filtre)
    - Barre de progression animée
    - Compteurs live avec transitions
    - Zone résultats avec liens

    **Pattern SSE côté client (dans index.html) :**
    ```javascript
    const es = new EventSource('/workflow/progress');
    es.addEventListener('progress', (e) => { /* update UI */ });
    es.addEventListener('complete', (e) => { es.close(); /* show results */ });
    es.addEventListener('error', (e) => { es.close(); /* show error */ });
    ```

    **IMPORTANT — Ce qu'il ne faut PAS faire :**
    - Ne pas importer WorkflowService directement (couplage Rich)
    - Ne pas utiliser Rich Console/Progress dans le code web
    - Ne pas implémenter le transfert (Phase 4)
    - Ne pas bloquer sur les undersized files (ignorer silencieusement avec info)
  </action>
  <verify>
    source .venv/bin/activate && python -c "from src.web.routes.workflow import router; print('Routes OK:', [r.path for r in router.routes])"
    source .venv/bin/activate && uvicorn src.web.app:app --host 0.0.0.0 --port 8000 &
    # Vérifier que GET /workflow retourne 200
    curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/workflow
  </verify>
  <done>AC-1, AC-2, AC-3, AC-4, AC-5 satisfied</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Page workflow complète avec :
    - Bouton de lancement du traitement (scan → matching → auto-validation)
    - Suivi de progression en temps réel via SSE
    - Affichage des résultats avec lien vers /validation
    - Gestion des erreurs
  </what-built>
  <how-to-verify>
    1. Lancer : source .venv/bin/activate && uvicorn src.web.app:app --reload --host 0.0.0.0 --port 8000
    2. Visiter : http://localhost:8000/workflow
    3. Vérifier : la page affiche un formulaire de lancement avec le bouton et le sélecteur de filtre
    4. Placer quelques fichiers vidéo dans le répertoire de téléchargements
    5. Cliquer "Lancer le traitement"
    6. Vérifier : la barre de progression s'anime avec les étapes (scan, matching, auto-validation)
    7. Vérifier : les compteurs se mettent à jour en temps réel
    8. Vérifier : à la fin, les résultats s'affichent (scannés, auto-validés, en attente)
    9. Vérifier : le lien vers /validation est présent si des fichiers sont en attente
    10. Vérifier : le design est cohérent avec le thème sombre existant
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/services/workflow/workflow_service.py (le workflow CLI reste intact)
- src/services/workflow/scan_step.py (mixin CLI)
- src/services/workflow/matching_step.py (mixin CLI)
- src/services/workflow/transfer_step.py (mixin CLI)
- src/web/routes/validation.py (routes Phase 2)
- src/web/templates/validation/* (templates Phase 2)

## SCOPE LIMITS
- Pas de transfert de fichiers (Phase 4)
- Pas de résolution de conflits (Phase 4)
- Pas de gestion des undersized en mode interactif (ignorés automatiquement côté web)
- Pas de validation manuelle dans le workflow (déjà fait en Phase 2 via /validation)

</boundaries>

<verification>
Before declaring plan complete:
- [ ] source .venv/bin/activate && python -c "from src.web.routes.workflow import router"
- [ ] GET /workflow retourne 200
- [ ] POST /workflow/start lance le workflow
- [ ] GET /workflow/progress retourne des events SSE
- [ ] Les résultats s'affichent à la fin du workflow
- [ ] Le design est cohérent avec le thème existant
- [ ] pytest existants passent toujours (pas de régression)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Workflow web fonctionnel de bout en bout (scan → matching → auto-validation → résultats)
- SSE progression visible en temps réel
- Lien vers /validation pour la suite manuelle
</success_criteria>

<output>
After completion, create `.paul/phases/03-orchestration-workflow/03-01-SUMMARY.md`
</output>
