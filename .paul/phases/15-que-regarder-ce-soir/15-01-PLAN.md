---
phase: 15-que-regarder-ce-soir
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/persistence/models.py
  - src/infrastructure/persistence/repositories/movie_repository.py
  - src/web/routes/library/detail.py
  - src/web/templates/library/movie_detail.html
  - src/web/static/style.css
  - src/web/routes/library/browse.py
  - src/web/templates/library/_filters.html
autonomous: false
---

<objective>
## Goal
Ajouter les champs "déjà vu" (watched) et note personnelle (étoiles 1-5) aux films, avec toggle et widget interactif sur la fiche film.

## Purpose
Fondations nécessaires pour la suggestion "Que regarder ce soir ?" : sans savoir quels films ont été vus et quels sont les préférés, impossible de faire des suggestions pertinentes.

## Output
- Colonnes `watched` et `personal_rating` ajoutées au modèle MovieModel
- Toggle "Déjà vu" cliquable sur la fiche film (HTMX)
- Widget étoiles cliquable (1-5) sur la fiche film (HTMX)
- Routes API pour toggle et rate
- Case à cocher "Non-vus" sur la page bibliothèque pour filtrer les films non encore vus
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md
@.paul/STATE.md

## Source Files
@src/infrastructure/persistence/models.py
@src/infrastructure/persistence/repositories/movie_repository.py
@src/web/routes/library/detail.py
@src/web/templates/library/movie_detail.html
@src/web/routes/library/browse.py
@src/web/templates/library/_filters.html
</context>

<skills>
## Required Skills (from SPECIAL-FLOWS.md)

| Skill | Priority | When to Invoke | Loaded? |
|-------|----------|----------------|---------|
| /frontend-design | required | Widget étoiles et toggle watched | ○ |

**BLOCKING:** /frontend-design MUST be loaded before APPLY proceeds.

## Skill Invocation Checklist
- [ ] /frontend-design loaded
</skills>

<acceptance_criteria>

## AC-1: Champs DB watched et personal_rating
```gherkin
Given la base de données SQLite existante
When l'application démarre
Then les colonnes watched (bool, default false) et personal_rating (int nullable) existent sur MovieModel
And les données existantes ne sont pas perdues
```

## AC-2: Toggle "Déjà vu" sur la fiche film
```gherkin
Given l'utilisateur est sur la fiche d'un film
When il clique sur le bouton "Déjà vu"
Then l'état watched est inversé en DB via HTMX (sans rechargement de page)
And l'icône/bouton reflète le nouvel état visuellement
```

## AC-3: Widget étoiles sur la fiche film
```gherkin
Given l'utilisateur est sur la fiche d'un film
When il clique sur une étoile (1 à 5)
Then la note personal_rating est enregistrée en DB via HTMX
And les étoiles reflètent la note visuellement (pleines/vides)
And cliquer sur la même étoile efface la note (toggle off)
```

## AC-4: Tests unitaires
```gherkin
Given les nouvelles routes toggle-watched et rate
When les tests sont exécutés
Then les tests vérifient le toggle, la notation, et la persistance en DB
```

## AC-5: Filtre "Non-vus" sur la page bibliothèque
```gherkin
Given l'utilisateur est sur la page bibliothèque
When la case "Non-vus" n'est pas cochée
Then tous les films/séries sont affichés (comportement actuel)

Given l'utilisateur est sur la page bibliothèque
When il coche la case "Non-vus"
Then seuls les films dont watched=false sont affichés
And le filtre est compatible avec les autres filtres existants (genre, année, etc.)
And le filtre est préservé dans la pagination
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Ajouter colonnes watched et personal_rating au modèle</name>
  <files>src/infrastructure/persistence/models.py</files>
  <action>
    Ajouter à MovieModel :
    - `watched: bool = Field(default=False, index=True)` — film déjà vu
    - `personal_rating: Optional[int] = Field(default=None)` — note 1-5, None = pas noté

    SQLModel avec SQLite ajoute automatiquement les colonnes manquantes au démarrage si on utilise `create_all`.
    Vérifier que `database.py` appelle `SQLModel.metadata.create_all()` — les nouvelles colonnes seront ajoutées avec leurs défauts.

    Note : Ne PAS ajouter à SeriesModel/EpisodeModel pour l'instant — on se concentre sur les films. L'extension aux séries viendra plus tard si nécessaire.

    Avoid: Ne pas créer de fichier de migration Alembic — le projet utilise create_all() de SQLModel.
  </action>
  <verify>
    `uv run python -c "from src.infrastructure.persistence.models import MovieModel; print([c.name for c in MovieModel.__table__.columns])"` — vérifier que watched et personal_rating sont dans la liste
  </verify>
  <done>AC-1 satisfait : colonnes watched et personal_rating dans MovieModel</done>
</task>

<task type="auto">
  <name>Task 2: Routes API toggle-watched et rate</name>
  <files>src/web/routes/library/detail.py, src/infrastructure/persistence/repositories/movie_repository.py</files>
  <action>
    1. Dans `movie_repository.py`, ajouter :
       - `toggle_watched(movie_id) -> bool` : inverse watched, retourne le nouvel état
       - `set_personal_rating(movie_id, rating: Optional[int])` : met à jour personal_rating

    2. Dans `detail.py`, ajouter :
       - `POST /library/movies/{movie_id}/toggle-watched` : appelle toggle_watched, retourne le fragment HTML du bouton mis à jour
       - `POST /library/movies/{movie_id}/rate` : reçoit `rating` (int 1-5), appelle set_personal_rating, retourne le fragment HTML des étoiles mises à jour
       - Si la même note est renvoyée (toggle off), passer None pour effacer

    Les réponses sont des fragments HTML (HTMX swap) pour mettre à jour l'UI sans rechargement.

    Avoid: Ne pas utiliser de session/cookies — l'état est en DB. Ne pas faire de redirect, retourner des fragments HTML.
  </action>
  <verify>
    `uv run pytest tests/ -x -q` — aucune régression
    Test manuel : curl -X POST localhost:8000/library/movies/{id}/toggle-watched
  </verify>
  <done>AC-2 et AC-3 partiellement satisfaits : routes API fonctionnelles</done>
</task>

<task type="auto">
  <name>Task 3: UI toggle "Déjà vu" et widget étoiles sur la fiche film</name>
  <files>src/web/templates/library/movie_detail.html, src/web/static/style.css</files>
  <action>
    1. Dans `movie_detail.html`, ajouter une zone d'actions personnelles (sous le titre ou près des boutons existants) :

       **Toggle "Déjà vu" :**
       - Bouton/badge avec icône œil (ouvert/fermé selon état)
       - `hx-post="/library/movies/{{ movie.id }}/toggle-watched"` `hx-target="#watched-zone"` `hx-swap="innerHTML"`
       - Le fragment retourné contient le bouton mis à jour avec le bon état

       **Widget étoiles :**
       - 5 étoiles cliquables (SVG star filled/empty)
       - Chaque étoile : `hx-post="/library/movies/{{ movie.id }}/rate"` avec `hx-vals='{"rating": N}'`
       - `hx-target="#rating-zone"` `hx-swap="innerHTML"`
       - Le fragment retourné contient les 5 étoiles avec le bon état

    2. Dans `style.css`, ajouter les styles :
       - `.watched-btn` : badge toggle avec état actif/inactif
       - `.star-rating` : conteneur étoiles inline
       - `.star` : étoile cliquable avec hover effect
       - `.star.filled` : étoile pleine (couleur dorée)
       - Style cohérent avec le thème sombre existant (Instrument Serif + DM Sans)

    Avoid: Pas de JavaScript custom — tout via HTMX et CSS. Pas de librairie externe pour les étoiles.
  </action>
  <verify>
    Lancer le serveur, aller sur une fiche film :
    - Vérifier le toggle "Déjà vu" (clic → changement visuel)
    - Vérifier les étoiles (clic → étoiles remplies, re-clic même → effacement)
    - Vérifier que les données persistent (refresh page)
  </verify>
  <done>AC-2 et AC-3 satisfaits : toggle et étoiles fonctionnels sur la fiche film</done>
</task>

<task type="auto">
  <name>Task 4: Case à cocher "Non-vus" sur la page bibliothèque</name>
  <files>src/web/routes/library/browse.py, src/web/templates/library/_filters.html</files>
  <action>
    1. Dans `browse.py` :
       - Lire le paramètre `unwatched` (str, défaut "") depuis la query string
       - Si `unwatched == "1"` : ajouter un filtre `MovieModel.watched == False` à la requête films
       - Pour les séries : pas de filtre watched (le champ n'existe pas sur SeriesModel)
       - Passer `current_unwatched` au contexte du template

    2. Dans `_filters.html` :
       - Ajouter une case à cocher dans la ligne de filtres, après les selects existants :
         ```html
         <label class="lib-filter-checkbox">
           <input type="checkbox" name="unwatched" value="1"
                  {{ 'checked' if current_unwatched }}
                  hx-get="/library/" hx-target="#library-content" hx-include="closest form">
           Non-vus
         </label>
         ```
       - Le trigger HTMX existant (`change from:select`) doit être étendu pour inclure le checkbox :
         `hx-trigger="change from:select, change from:input[name=unwatched], keyup changed delay:700ms from:find input[name=q]"`
       - Ajouter `unwatched` dans `base_params` pour la préservation dans la pagination et les tags de filtres actifs

    3. Dans `style.css` :
       - `.lib-filter-checkbox` : label inline avec style cohérent (couleur, font DM Sans)
       - Checkbox custom ou natif stylé pour le thème sombre

    Avoid: Ne pas filtrer les séries par watched (le champ n'existe pas). La case non cochée = pas de paramètre envoyé = comportement par défaut.
  </action>
  <verify>
    Lancer le serveur, aller sur /library :
    - Vérifier que sans la case cochée, tous les films apparaissent
    - Cocher "Non-vus" → seuls les films non marqués "déjà vu" apparaissent
    - Combiner avec un autre filtre (genre, année) → le filtre se cumule
    - Changer de page → le filtre est préservé
  </verify>
  <done>AC-5 satisfait : case "Non-vus" fonctionnelle sur la page bibliothèque</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Toggle "Déjà vu", widget étoiles sur les fiches films, et filtre "Non-vus" sur la bibliothèque</what-built>
  <how-to-verify>
    1. Lancer le serveur : `uv run uvicorn src.web.app:app --reload --host 0.0.0.0`
    2. Aller sur http://192.168.1.15:8000/library
    3. Ouvrir une fiche film
    4. Cliquer sur "Déjà vu" → vérifier le changement visuel
    5. Cliquer sur une étoile (ex: 4) → vérifier les étoiles remplies
    6. Cliquer sur la même étoile → vérifier l'effacement
    7. Rafraîchir la page → vérifier que l'état persiste
    8. Retourner sur /library → cocher "Non-vus" → vérifier que les films marqués "déjà vu" disparaissent
    9. Combiner "Non-vus" avec un filtre genre → vérifier le cumul
    10. Répéter sur 2-3 films différents
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/services/workflow/ (logique métier workflow)
- src/adapters/cli/ (CLI ne doit pas être impacté)
- SeriesModel, EpisodeModel (pas de modification pour l'instant)
- Logique de validation/transfert existante

## SCOPE LIMITS
- Films uniquement — pas de "déjà vu" pour séries/épisodes dans ce plan
- Filtre "Non-vus" s'applique aux films uniquement (SeriesModel n'a pas le champ watched)
- Pas de page suggestion (plan 02)
- Pas de modification du footer version (plan 02)
- Pas de bouton accueil (plan 02)

</boundaries>

<verification>
Before declaring plan complete:
- [ ] Colonnes watched et personal_rating dans MovieModel
- [ ] Toggle "Déjà vu" fonctionnel sur fiche film
- [ ] Widget étoiles fonctionnel sur fiche film
- [ ] Persistance DB vérifiée (refresh page)
- [ ] Case "Non-vus" fonctionnelle sur page bibliothèque
- [ ] Filtre "Non-vus" compatible avec les autres filtres et la pagination
- [ ] `uv run pytest` — aucune régression
- [ ] `uv run ruff check src/` — pas d'erreur lint
</verification>

<success_criteria>
- Toutes les tâches complétées
- Toutes les vérifications passent
- Pas d'erreurs ni d'avertissements introduits
- Les films peuvent être marqués "déjà vu" et notés 1-5 étoiles
- La bibliothèque peut être filtrée pour ne montrer que les films non-vus
</success_criteria>

<output>
After completion, create `.paul/phases/15-que-regarder-ce-soir/15-01-SUMMARY.md`
</output>
