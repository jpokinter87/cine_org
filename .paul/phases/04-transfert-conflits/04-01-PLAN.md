---
phase: 04-transfert-conflits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/web/routes/transfer.py
  - src/web/templates/transfer/index.html
  - src/web/templates/transfer/_batch_tree.html
  - src/web/templates/transfer/_progress.html
  - src/web/templates/transfer/_results.html
  - src/web/templates/transfer/_conflict.html
  - src/web/static/css/style.css
  - src/web/app.py
autonomous: false
---

<objective>
## Goal
Interface web pour le résumé batch des transferts, la confirmation et l'exécution avec progression SSE, et la résolution interactive de conflits (doublons / collisions de noms / contenu similaire).

## Purpose
Après le workflow (scan → matching → validation), les fichiers validés doivent être transférés vers storage/ avec création de symlinks dans video/. Cette étape finale du pipeline n'existe actuellement qu'en CLI. L'interface web permet à l'utilisateur de visualiser l'arborescence des transferts prévus, résoudre les conflits visuellement (comparaison technique côte à côte), et exécuter le transfert avec suivi de progression temps réel.

## Output
- Page /transfer avec liste des fichiers validés prêts à transférer
- Arborescence visuelle des transferts prévus (Films/Séries, destinations)
- Exécution du transfert avec progression SSE
- Détection et résolution interactive des conflits (DUPLICATE, NAME_COLLISION, SIMILAR_CONTENT)
- Affichage comparatif des fichiers en conflit (taille, résolution, codec, durée)
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md
@.paul/STATE.md

## Prior Work
@.paul/phases/03-orchestration-workflow/03-01-SUMMARY.md
- Phase 3 fournit le pattern SSE (WorkflowProgress + EventSource) réutilisable
- Services individuels réutilisés directement (pas WorkflowService couplé Rich)
- Cascade auto-validation séries implémentée dans la route web

## Source Files
@src/services/transferer.py (TransfererService, ConflictType, ConflictInfo, SimilarContentInfo, ExistingFileInfo, TransferResult)
@src/adapters/cli/batch_builder.py (build_transfers_batch, TransferData, _enrich_movie_metadata, _build_series_transfer_data)
@src/adapters/cli/validation/batch_display.py (display_batch_summary, execute_batch_transfer, display_similar_content_conflict, prompt_conflict_resolution, ConflictResolution)
@src/services/organizer.py (OrganizerService — get_movie_destination, get_series_destination)
@src/services/renamer.py (RenamerService — generate_movie_filename, generate_series_filename)
@src/web/routes/workflow.py (Pattern SSE existant à réutiliser)
</context>

<skills>
## Required Skills (from SPECIAL-FLOWS.md)

| Skill | Priority | When to Invoke | Loaded? |
|-------|----------|----------------|---------|
| /frontend-design | required | Avant création des templates transfer/ et CSS | ○ |

**BLOCKING:** Required skills MUST be loaded before APPLY proceeds.
Run each skill command or confirm already loaded.

## Skill Invocation Checklist
- [ ] /frontend-design loaded (run command or confirm)

</skills>

<acceptance_criteria>

## AC-1: Page transfert avec résumé batch
```gherkin
Given des fichiers en statut VALIDATED existent dans la base
When l'utilisateur accède à GET /transfer
Then il voit une arborescence des transferts prévus (Films groupés par genre/lettre, Séries par type/lettre/titre/saison)
And chaque fichier affiche le nouveau nom, la destination storage et la destination symlink
And un compteur total indique "N fichier(s) prêt(s) à transférer"
```

## AC-2: Page transfert vide
```gherkin
Given aucun fichier VALIDATED n'existe
When l'utilisateur accède à GET /transfer
Then il voit un message explicatif "Aucun fichier validé à transférer"
And un lien vers /workflow pour lancer un traitement
And un lien vers /validation si des fichiers sont en attente
```

## AC-3: Exécution du transfert avec progression SSE
```gherkin
Given des fichiers validés sans conflit sont prêts à transférer
When l'utilisateur clique sur "Lancer le transfert"
Then une barre de progression SSE s'affiche (fichier en cours, N/total)
And chaque fichier est transféré (move + symlink) séquentiellement
And à la fin, un résumé affiche le nombre de fichiers transférés avec succès/erreur
```

## AC-4: Détection et résolution de conflit DUPLICATE
```gherkin
Given un fichier validé a le même hash qu'un fichier existant dans storage/
When le transfert détecte un conflit DUPLICATE
Then le fichier est automatiquement ignoré (pas de transfert)
And le résumé final indique "N doublon(s) ignoré(s)"
```

## AC-5: Détection et résolution de conflit NAME_COLLISION ou SIMILAR_CONTENT
```gherkin
Given un fichier validé entre en collision de nom ou contenu similaire avec un fichier existant
When le transfert détecte un conflit NAME_COLLISION ou SIMILAR_CONTENT
Then le transfert se met en pause
And un dialogue comparatif s'affiche (taille, résolution, codec vidéo, codec audio, durée)
And l'utilisateur peut choisir : garder l'ancien, garder le nouveau, garder les deux, ou passer
And le transfert reprend après le choix
```

## AC-6: Résultats finaux
```gherkin
Given le transfert est terminé (avec ou sans conflits)
When l'event SSE "complete" est reçu
Then le résumé affiche : transférés avec succès, doublons ignorés, conflits résolus, erreurs
And un bouton "Retour au workflow" est affiché
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Routes transfert + construction batch web</name>
  <files>src/web/routes/transfer.py, src/web/app.py</files>
  <action>
    Créer src/web/routes/transfer.py avec les routes suivantes :

    **GET /transfer** — Page principale :
    - Récupérer les fichiers validés via `validation_service.list_validated()`
    - Si aucun validé : retourner template avec message vide + liens workflow/validation
    - Sinon : appeler `build_transfers_batch()` (réutiliser depuis batch_builder.py) pour construire la liste des transferts
    - Important : `build_transfers_batch` utilise `rich.Console` — il faut l'adapter pour le web en rendant le console.print optionnel ou en utilisant un null console. Alternative : extraire les données sans les afficher (la fonction fait des print pendant l'enrichissement des films, il faut les supprimer ou rediriger)
    - Séparer les transferts en films/séries pour le template
    - Grouper par arborescence : Films → genre/lettre/fichier, Séries → type/lettre/titre/saison/fichier
    - Stocker la liste des transferts dans `request.app.state.transfer_batch` pour usage par POST

    **POST /transfer/start** — Lancer le transfert :
    - Récupérer `request.app.state.transfer_batch`
    - Créer un `TransferProgress` (similaire à WorkflowProgress de Phase 3)
    - Lancer `_run_web_transfer()` en asyncio.Task
    - Retourner le fragment _progress.html

    **GET /transfer/progress** — SSE endpoint :
    - Même pattern que workflow SSE (StreamingResponse + EventSource)
    - Events : progress (fichier en cours, N/total), conflict (pause pour résolution), complete (résumé final)

    **POST /transfer/resolve-conflict** — Résoudre un conflit :
    - Recevoir le choix de l'utilisateur (keep_old, keep_new, keep_both, skip)
    - Mettre à jour l'état du conflit dans TransferProgress
    - Signal asyncio.Event pour reprendre le transfert

    **Fonction _run_web_transfer()** :
    - Pour chaque transfert :
      1. Vérifier conflit via `transferer.check_conflict(source, destination)`
      2. Si DUPLICATE : incrémenter compteur doublons, passer au suivant
      3. Si NAME_COLLISION : vérifier aussi `find_similar_content()`, mettre en pause, envoyer event SSE "conflict", attendre résolution
      4. Si SIMILAR_CONTENT : idem
      5. Si pas de conflit : `transferer.transfer_file(source, destination, symlink_destination=...)`
      6. Mettre à jour la progression SSE
    - À la fin : envoyer event "complete" avec les compteurs

    **TransferProgress class** :
    - Hériter du pattern WorkflowProgress
    - Ajouter : conflict_pending (ConflictInfo en attente), conflict_resolved (Event asyncio), conflict_choice (str)
    - Ajouter compteurs : transferred, duplicates_ignored, conflicts_resolved, errors

    Modifier src/web/app.py pour monter le router transfer.

    Éviter :
    - Ne PAS utiliser Rich/Confirm (CLI only) dans les routes web
    - Ne PAS dupliquer la logique de build_transfers_batch — la réutiliser, mais neutraliser les print Rich (passer un null console ou supprimer les console.print dans la fonction)
  </action>
  <verify>
    - Le serveur démarre sans erreur : `source .venv/bin/activate && python -c "from src.web.routes.transfer import router"`
    - Les routes sont montées : vérifier dans app.py
  </verify>
  <done>AC-1, AC-2, AC-3, AC-4, AC-5, AC-6 (backend complet)</done>
</task>

<task type="auto">
  <name>Task 2: Templates transfert + CSS (avec /frontend-design)</name>
  <files>
    src/web/templates/transfer/index.html,
    src/web/templates/transfer/_batch_tree.html,
    src/web/templates/transfer/_progress.html,
    src/web/templates/transfer/_results.html,
    src/web/templates/transfer/_conflict.html,
    src/web/static/css/style.css
  </files>
  <action>
    Invoquer /frontend-design avant de créer les templates.

    **transfer/index.html** — Page principale :
    - Extends base.html
    - Si pas de transferts : message "Aucun fichier validé" + liens workflow/validation
    - Sinon : inclure _batch_tree.html + bouton "Lancer le transfert"
    - Le bouton POST vers /transfer/start via HTMX (hx-post, hx-target="#transfer-area")

    **transfer/_batch_tree.html** — Arborescence des transferts :
    - Structure visuelle en arbre (CSS, pas Rich Tree)
    - Films groupés : genre → lettre → fichier (nouveau nom + destination)
    - Séries groupées : type → lettre → titre (année) → saison → épisodes
    - Chaque fichier montre : nouveau nom, taille source, destination storage (en dim)
    - Compteur total en haut ("N fichier(s) à transférer")

    **transfer/_progress.html** — Fragment progression SSE :
    - Même structure que workflow/_progress.html (barre + étapes + compteur + fichier en cours)
    - 1 seule étape "Transfert" (pas 4 comme le workflow)
    - EventSource sur /transfer/progress
    - Gestion event "conflict" : injecter dynamiquement _conflict.html dans la page

    **transfer/_conflict.html** — Dialogue de résolution de conflit :
    - Overlay/dialogue (même style que les dialogues destructifs existants)
    - Tableau comparatif : existant vs nouveau (fichiers, taille, résolution, codec vidéo, codec audio)
    - Raison de la similarité affichée
    - 4 boutons : Garder l'ancien, Garder le nouveau, Garder les deux, Passer
    - Chaque bouton POST vers /transfer/resolve-conflict avec le choix
    - L'overlay se ferme après POST, la progression reprend

    **transfer/_results.html** — Fragment résultats :
    - Compteurs : transférés, doublons ignorés, conflits résolus, erreurs
    - Style cohérent avec workflow/_results.html (result-grid, tooltips)
    - Bouton "Retour au workflow"

    **CSS (style.css)** — Ajouts :
    - Styles pour l'arborescence (.transfer-tree, .tree-branch, .tree-leaf)
    - Styles pour le dialogue de conflit (.conflict-overlay, .conflict-card, .conflict-table)
    - Styles pour la comparaison technique (.compare-grid, .compare-value)
    - Réutiliser les styles existants de progression workflow
  </action>
  <verify>
    - Les templates sont syntaxiquement valides (pas d'erreur Jinja2 à l'ouverture de /transfer)
    - Le CSS ne casse pas les pages existantes
  </verify>
  <done>AC-1, AC-2, AC-5, AC-6 (frontend complet)</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Page transfert web complète avec arborescence batch, progression SSE, et résolution de conflits</what-built>
  <how-to-verify>
    1. Lancer le serveur : `source .venv/bin/activate && uvicorn src.web.app:app --reload`
    2. Accéder à http://127.0.0.1:8000/transfer
    3. Vérifier cas vide : si pas de fichiers validés, voir message + liens
    4. Lancer un workflow via /workflow pour créer des fichiers validés
    5. Retourner sur /transfer et vérifier :
       - Arborescence des transferts (films/séries organisés)
       - Compteur total
    6. Cliquer "Lancer le transfert" :
       - Barre de progression SSE visible
       - Fichier en cours affiché
       - Résumé final avec compteurs
    7. Si conflit détecté : dialogue comparatif affiché avec les 4 options
    8. Vérifier que les fichiers ont été déplacés dans storage/ et symlinks créés dans video/
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/services/transferer.py (service stable, uniquement le consommer)
- src/services/organizer.py (service stable)
- src/services/renamer.py (service stable)
- src/web/routes/workflow.py (Phase 3, stable)
- src/web/routes/validation.py (Phase 2-3, stable)
- src/web/templates/workflow/* (Phase 3, stable)
- src/web/templates/validation/* (Phase 2, stable)

## SCOPE LIMITS
- Pas de navigation bibliothèque (Phase 5)
- Pas de modification des services de transfert/organizer/renamer
- Pas de tests unitaires dans ce plan (les services sont déjà testés, le web est vérifié par UAT)
- La logique de build_transfers_batch peut être réutilisée telle quelle ou légèrement adaptée pour supprimer les dépendances Rich, mais pas de refactoring majeur

</boundaries>

<verification>
Before declaring plan complete:
- [ ] `source .venv/bin/activate && python -c "from src.web.app import app"` — import sans erreur
- [ ] `source .venv/bin/activate && uvicorn src.web.app:app --reload` — serveur démarre
- [ ] GET /transfer affiche la page (vide ou avec batch)
- [ ] POST /transfer/start lance le transfert avec SSE
- [ ] Conflits détectés et dialogue affiché (si applicable)
- [ ] Fichiers transférés correctement (storage/ + symlinks video/)
- [ ] Pages existantes (/, /workflow, /validation) non cassées
- [ ] All acceptance criteria met
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Transfer page shows batch tree for validated files
- SSE progression works during transfer execution
- Conflicts detected and resolved interactively
- No errors or warnings introduced
- Existing pages (home, workflow, validation) unchanged
</success_criteria>

<output>
After completion, create `.paul/phases/04-transfert-conflits/04-01-SUMMARY.md`
</output>
