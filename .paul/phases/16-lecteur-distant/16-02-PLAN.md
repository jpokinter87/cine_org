---
phase: 16-lecteur-distant
plan: 02
type: execute
wave: 1
depends_on: ["16-01"]
files_modified:
  - src/config.py
  - src/web/routes/library/player.py
  - src/web/routes/config.py
  - src/web/templates/config/index.html
  - tests/unit/test_player.py
autonomous: false
---

<objective>
## Goal
Remplacer la configuration lecteur unique par un système de profils nommés, permettant de basculer instantanément entre machines cibles (local, Xubuntu, Windows, etc.).

## Purpose
Actuellement, changer de machine cible nécessite de modifier 6 champs dans la config. Avec les profils, un clic suffit pour basculer entre "Local", "Xubuntu salon", "Windows bureau", etc.

## Output
- Fichier `player_profiles.json` avec profils nommés
- Sélecteur de profil actif dans la section Lecteur de /config
- Formulaire d'ajout/édition/suppression de profils
- player.py charge le profil actif depuis le JSON
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md

## Prior Work
@.paul/phases/16-lecteur-distant/16-01-PLAN.md — Lecteur configurable (base)

## Source Files
@src/config.py — Settings avec 6 champs player_* à remplacer par player_active_profile
@src/web/routes/library/player.py — Charge Settings() pour les params lecteur
@src/web/routes/config.py — Page config, section "player" avec 6 champs
@src/web/templates/config/index.html — Template config
</context>

<acceptance_criteria>

## AC-1: Profils stockés en JSON
```gherkin
Given un fichier player_profiles.json à la racine du projet
When il contient les profils "Local" et "Xubuntu salon"
Then chaque profil a les champs : command, target, ssh_host, ssh_user, local_path_prefix, remote_path_prefix
And un champ "active" indique le profil actif
```

## AC-2: Sélection rapide du profil actif
```gherkin
Given la page /config avec 3 profils configurés
When l'utilisateur clique sur un profil dans la section Lecteur
Then le profil actif change immédiatement (sauvegardé dans le JSON)
And le bouton Visionner utilise les paramètres du nouveau profil actif
```

## AC-3: CRUD profils
```gherkin
Given la section Lecteur dans /config
When l'utilisateur clique "Ajouter un profil"
Then un formulaire apparaît avec les 6 champs (nom, programme, cible, SSH host/user, préfixes)
And il peut sauvegarder, modifier ou supprimer des profils existants
And le profil "Local" par défaut ne peut pas être supprimé
```

## AC-4: Migration transparente
```gherkin
Given un utilisateur avec les anciens champs player_* dans .env
When il met à jour l'application
Then un profil est automatiquement créé à partir des anciens paramètres
And les anciens champs player_* dans Settings sont retirés
```

## AC-5: Fallback si pas de profil
```gherkin
Given aucun fichier player_profiles.json
When l'utilisateur clique Visionner
Then le lecteur mpv est lancé localement (comportement par défaut)
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Créer le module player_profiles et migrer Settings</name>
  <files>src/player_profiles.py, src/config.py</files>
  <action>
    Créer src/player_profiles.py avec :

    1. Constante _PROFILES_FILE = _PROJECT_ROOT / "player_profiles.json"
    2. Dataclass ou dict pour un profil :
       - name: str
       - command: str (défaut "mpv")
       - target: str (défaut "local")
       - ssh_host: str | None
       - ssh_user: str | None
       - local_path_prefix: str | None
       - remote_path_prefix: str | None
    3. Fonctions :
       - load_profiles() -> dict : charge le JSON, crée le défaut si absent
       - save_profiles(data: dict) : écrit le JSON
       - get_active_profile() -> dict : retourne le profil actif (ou défaut local)
       - set_active_profile(name: str) : change le profil actif
       - add_profile(profile: dict) : ajoute un profil
       - update_profile(name: str, profile: dict) : met à jour
       - delete_profile(name: str) : supprime (interdit pour "Local")
    4. Format JSON :
       {
         "active": "Local",
         "profiles": [
           {"name": "Local", "command": "mpv", "target": "local", ...},
           {"name": "Xubuntu salon", "command": "env DISPLAY=:0 mpv", "target": "remote", ...}
         ]
       }
    5. Migration : au premier load_profiles(), si le fichier n'existe pas ET que
       les anciens player_* sont dans .env, créer un profil à partir de ces valeurs.

    Dans config.py :
    - Retirer les 6 champs player_* de Settings
    - Garder la classe Settings propre (pas de lecteur)

    Éviter : ne PAS utiliser de base de données, un simple fichier JSON suffit
  </action>
  <verify>uv run python -c "from src.player_profiles import load_profiles, get_active_profile; p = get_active_profile(); print(p)"</verify>
  <done>AC-1, AC-4, AC-5 satisfaits</done>
</task>

<task type="auto">
  <name>Task 2: Adapter player.py pour charger le profil actif</name>
  <files>src/web/routes/library/player.py, tests/unit/test_player.py</files>
  <action>
    Dans player.py :
    - Remplacer Settings() par get_active_profile() pour les paramètres lecteur
    - _launch_player : charger le profil actif, extraire command/target/ssh_host/etc.
    - _play_button_html : charger le profil pour le label du lecteur
    - Adapter _launch_ssh et _map_path pour accepter un dict profil au lieu de Settings

    Dans tests/unit/test_player.py :
    - Adapter les mocks : mocker get_active_profile() au lieu de Settings()
    - Garder les mêmes scénarios de test (local, SSH, fallback, map_path)
  </action>
  <verify>uv run pytest tests/unit/test_player.py -v</verify>
  <done>AC-2 partiellement satisfait (backend), AC-5 satisfait</done>
</task>

<task type="auto">
  <name>Task 3: UI de gestion des profils dans /config</name>
  <files>src/web/routes/config.py, src/web/templates/config/index.html</files>
  <action>
    Dans config.py :
    - Retirer la section "player" de _SECTIONS (les 6 champs)
    - Ajouter des routes pour la gestion des profils :
      - GET /config/player-profiles : fragment HTMX avec la liste des profils
      - POST /config/player-profiles/active : changer le profil actif
      - POST /config/player-profiles/add : ajouter un profil
      - POST /config/player-profiles/{name}/edit : modifier un profil
      - POST /config/player-profiles/{name}/delete : supprimer un profil
    - Passer les profils au template dans config_page()

    Dans index.html :
    - Remplacer la section player (6 champs) par :
      - Liste des profils avec le profil actif mis en évidence (badge/couleur)
      - Clic sur un profil = POST HTMX pour le rendre actif
      - Bouton "Ajouter" qui ouvre un formulaire inline (6 champs + nom)
      - Bouton "Modifier" sur chaque profil (édition inline)
      - Bouton "Supprimer" sur chaque profil (sauf "Local")
    - Style cohérent avec le thème sombre existant

    Éviter : ne PAS créer un template séparé, garder dans index.html
    Éviter : ne PAS utiliser de modal/overlay, formulaire inline suffit
  </action>
  <verify>Visiter /config et vérifier la section Lecteur avec profils</verify>
  <done>AC-2, AC-3 satisfaits</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Système de profils lecteur avec sélection rapide et CRUD</what-built>
  <how-to-verify>
    1. Lancer le serveur : uv run uvicorn src.web.app:app --reload
    2. Aller sur /config → section Lecteur
    3. Vérifier qu'un profil "Local" existe par défaut
    4. Ajouter un profil "Xubuntu salon" (remote, SSH configuré)
    5. Ajouter un profil "Windows bureau" (remote, SSH + path mapping)
    6. Basculer entre les profils en cliquant dessus
    7. Ouvrir une fiche film → Visionner → vérifier que le bon profil est utilisé
    8. Supprimer un profil → vérifier qu'il disparaît
    9. Tenter de supprimer "Local" → vérifier que c'est interdit
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/infrastructure/ (aucun changement DB)
- src/web/templates/library/ (templates de détail inchangés)
- Les routes movie_play/episode_play (signature inchangée)

## SCOPE LIMITS
- Pas de profils par utilisateur (mono-utilisateur)
- Pas de détection automatique des machines du réseau
- Simple fichier JSON, pas de table DB

</boundaries>

<verification>
Before declaring plan complete:
- [ ] uv run pytest tests/unit/test_player.py -v — tous les tests passent
- [ ] uv run pytest -x -q — pas de régression
- [ ] uv run ruff check src/player_profiles.py src/config.py src/web/routes/library/player.py src/web/routes/config.py
- [ ] player_profiles.json créé automatiquement au premier accès
- [ ] Profil "Local" par défaut fonctionne
- [ ] Basculement entre profils fonctionne
- [ ] Lecture locale et distante fonctionnent selon le profil actif
</verification>

<success_criteria>
- Tous les tests passent
- Basculement de profil en un clic
- CRUD profils fonctionnel
- Migration transparente des anciens paramètres
- Lecture correcte selon le profil actif
</success_criteria>

<output>
After completion, create `.paul/phases/16-lecteur-distant/16-02-SUMMARY.md`
</output>
