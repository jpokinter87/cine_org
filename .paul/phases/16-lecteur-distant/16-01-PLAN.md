---
phase: 16-lecteur-distant
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.py
  - src/web/routes/library/player.py
  - src/web/routes/config.py
  - src/web/templates/config/index.html
  - tests/unit/test_player.py
autonomous: false
---

<objective>
## Goal
Rendre le lecteur vidéo configurable (programme, machine cible, mapping de chemins) et ajouter le lancement distant via SSH.

## Purpose
Permettre de lancer la lecture depuis la fiche web d'un film/série sur n'importe quelle machine du réseau LAN (HTPC salon, PC bureau, etc.), quel que soit l'OS (Linux/Windows).

## Output
- 5 nouveaux paramètres dans Settings + section "Lecteur" dans la page config
- player.py capable de lancer en local OU via SSH avec mapping de chemins
- Tests unitaires pour la logique de lancement
</objective>

<context>
## Project Context
@.paul/PROJECT.md
@.paul/ROADMAP.md

## Source Files
@src/config.py — Settings pydantic (aucun paramètre lecteur actuellement)
@src/web/routes/library/player.py — Lecteur actuel : mpv hardcodé, subprocess local
@src/web/routes/config.py — Page config web : système de sections _SECTIONS + .env
@src/web/templates/config/index.html — Template config
</context>

<skills>
## Required Skills (from SPECIAL-FLOWS.md)

| Skill | Priority | When to Invoke | Loaded? |
|-------|----------|----------------|---------|
| /frontend-design | required | Modification template config (section Lecteur) | ○ |

**BLOCKING:** /frontend-design doit être chargé avant l'exécution pour la Task 3.

## Skill Invocation Checklist
- [ ] /frontend-design loaded
</skills>

<acceptance_criteria>

## AC-1: Configuration lecteur local
```gherkin
Given un utilisateur avec player_command="vlc" et player_target="local"
When il clique "Visionner" sur une fiche film
Then vlc est lancé localement avec le chemin du fichier vidéo
```

## AC-2: Configuration lecteur distant SSH
```gherkin
Given un utilisateur avec player_target="remote", player_ssh_host="192.168.1.20", player_ssh_user="jp", player_remote_path_prefix="/mnt/nas"
When il clique "Visionner" sur un film dont le chemin local est /home/jp/Videos/storage/Films/Action/A/Alien.mkv
Then la commande SSH est exécutée : ssh jp@192.168.1.20 "mpv '/mnt/nas/storage/Films/Action/A/Alien.mkv'"
Et le chemin local /home/jp/Videos est remplacé par /mnt/nas
```

## AC-3: Fallback local si SSH non configuré
```gherkin
Given un utilisateur avec player_target="remote" mais player_ssh_host vide
When il clique "Visionner"
Then le lecteur est lancé localement (fallback gracieux)
```

## AC-4: Section Lecteur dans la page config
```gherkin
Given la page /config
When l'utilisateur la visite
Then une section "Lecteur" apparaît avec les champs : programme, cible, hôte SSH, utilisateur SSH, préfixe chemin local, préfixe chemin distant
And les valeurs sont sauvegardées dans .env via le formulaire existant
```

## AC-5: Feedback visuel SSH
```gherkin
Given une lecture lancée via SSH
When la commande SSH échoue (hôte injoignable, auth refusée)
Then un message d'erreur explicite est affiché dans le bouton (pas juste "Lecture en cours")
```

</acceptance_criteria>

<tasks>

<task type="auto">
  <name>Task 1: Ajouter les paramètres lecteur à Settings + section config</name>
  <files>src/config.py, src/web/routes/config.py</files>
  <action>
    Ajouter 6 champs à la classe Settings dans config.py :
    - player_command: str = "mpv" (programme lecteur)
    - player_target: str = "local" (local | remote)
    - player_ssh_host: Optional[str] = None (IP ou hostname)
    - player_ssh_user: Optional[str] = None (utilisateur SSH)
    - player_local_path_prefix: Optional[str] = None (préfixe chemin serveur, ex: /home/jp/Videos)
    - player_remote_path_prefix: Optional[str] = None (préfixe chemin distant, ex: /mnt/nas ou Z:\Videos)

    Dans config.py (_SECTIONS), ajouter une section "Lecteur" (id: "player", icon: "play") avec :
    - player_command : type "text"
    - player_target : type "select" options ["local", "remote"]
    - player_ssh_host : type "text"
    - player_ssh_user : type "text"
    - player_local_path_prefix : type "text"
    - player_remote_path_prefix : type "text"

    Positionner la section entre "Traitement" et "Journalisation".
  </action>
  <verify>uv run python -c "from src.config import Settings; s = Settings(); print(s.player_command, s.player_target)"</verify>
  <done>AC-4 partiellement satisfait : les paramètres existent et sont éditables</done>
</task>

<task type="auto">
  <name>Task 2: Refactorer player.py pour supporter local + SSH</name>
  <files>src/web/routes/library/player.py, tests/unit/test_player.py</files>
  <action>
    Refactorer _launch_player() dans player.py :

    1. Charger les Settings au lancement (Settings() — c'est léger, pydantic-settings)
    2. Fonction _map_path(local_path, settings) -> str :
       - Si player_local_path_prefix et player_remote_path_prefix sont définis :
         remplacer le préfixe local par le préfixe distant
       - Sinon retourner str(local_path)
    3. Fonction _launch_local(command, file_path) -> Popen :
       - subprocess.Popen([command, str(file_path)], stdout=DEVNULL, stderr=DEVNULL)
    4. Fonction _launch_ssh(settings, file_path) -> Popen :
       - Mapper le chemin via _map_path
       - Commande : ["ssh", f"{user}@{host}", f"{command} '{mapped_path}'"]
       - subprocess.Popen avec stdout=PIPE, stderr=PIPE pour capturer les erreurs
    5. _launch_player(file_path) :
       - Si target == "remote" ET ssh_host est défini → _launch_ssh
       - Sinon → _launch_local (fallback AC-3)
       - Retourner (pid, is_remote)
    6. Adapter play_status pour détecter les erreurs SSH :
       - Si process terminé avec returncode != 0, vérifier stderr
       - Retourner un fragment HTML d'erreur au lieu du bouton Visionner

    Écrire tests/unit/test_player.py :
    - Test _map_path avec préfixes configurés
    - Test _map_path sans préfixes (identité)
    - Test _map_path avec chemins Windows (backslash)
    - Test _launch_player fallback local quand SSH non configuré
    - Mocker subprocess.Popen pour les tests de lancement

    Éviter : ne PAS modifier les routes movie_play/episode_play (signature inchangée)
    Éviter : ne PAS stocker Settings en global — charger à chaque appel _launch_player
  </action>
  <verify>uv run pytest tests/unit/test_player.py -v</verify>
  <done>AC-1, AC-2, AC-3, AC-5 satisfaits</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Lecteur configurable local + SSH avec page config enrichie</what-built>
  <how-to-verify>
    1. Lancer le serveur : uv run uvicorn src.web.app:app --reload
    2. Aller sur /config → vérifier la section "Lecteur" avec les 6 champs
    3. Configurer : programme "mpv", cible "local" → sauvegarder → vérifier .env
    4. Ouvrir une fiche film → cliquer "Visionner" → mpv doit se lancer
    5. Configurer : cible "remote", remplir SSH host/user → sauvegarder
    6. Cliquer "Visionner" → vérifier que la commande SSH est tentée
       (si pas de machine SSH dispo, vérifier le message d'erreur)
    7. Vider SSH host → sauvegarder → vérifier le fallback local
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<boundaries>

## DO NOT CHANGE
- src/web/routes/library/detail.py (fiches films/séries — ne touche pas aux templates de détail)
- src/web/templates/library/movie_detail.html (les boutons Visionner existants restent identiques)
- src/web/templates/library/series_detail.html (idem)
- src/infrastructure/ (aucun changement DB nécessaire)

## SCOPE LIMITS
- Pas de streaming vidéo (le fichier doit être accessible sur la machine distante)
- Pas de découverte automatique des machines du réseau
- Pas de gestion de clés SSH (l'utilisateur configure ssh-copy-id lui-même)
- Un seul lecteur cible à la fois (pas de multi-room)

</boundaries>

<verification>
Before declaring plan complete:
- [ ] uv run pytest tests/unit/test_player.py -v — tous les tests passent
- [ ] uv run pytest — pas de régression
- [ ] uv run ruff check src/config.py src/web/routes/library/player.py src/web/routes/config.py
- [ ] Page /config affiche la section Lecteur avec tous les champs
- [ ] Lecture locale fonctionne avec le programme configuré
- [ ] Lecture SSH tentée quand configuré (ou message d'erreur clair)
- [ ] Fallback local quand SSH non configuré
</verification>

<success_criteria>
- Tous les tests passent (existants + nouveaux)
- La page config a une section Lecteur fonctionnelle
- Le lecteur respecte la configuration (.env)
- Le mapping de chemins fonctionne cross-platform
- Les erreurs SSH sont affichées clairement
</success_criteria>

<output>
After completion, create `.paul/phases/16-lecteur-distant/16-01-SUMMARY.md`
</output>
